Developed by Shunpower, StayAlone, Zelotz, H_Z_J, LPhang, WaterSun, harmis_yz

[Github - Shunpower - Qingdao Thoughts Repository](https://github.com/Shunpower/Qingdao-Thoughts/)

## 思考题

### 思考题 1：广义自动机

补充：自动机定义为输入一个序列，从左往右读入字符，每读入一个字符需要决定输出常数个字符（可以不输出）。

1. 给定一个长度为 $n$ 的加法算式，求这两个数字的和，这个问题是否可以用一个状态数 $O(1)$ 的自动机解决？如果可以，请构造出该自动机。
输入样例：$114514+1919810=$。 
2. 给定两个长度为 $n$ 的数字，求这两个数字的和，如果将两个数字分别从最高位开始交替输入，这个问题是否可以用一个状态数 $O(1)$ 的自动机解决？如果可以，请构造出该自动机。
输入样例：$12345678$，表示将 $1357$ 和 $2468$ 这两个数字求和。
3. 给定两个长度为 $n$ 的数字，求这两个数字的和，如果将两个数字分别从最低位开始交替输入，这个问题是否可以用一个状态数 $O(1)$ 的自动机解决？如果可以，请构造出该自动机。
输入样例：$87654321$，表示将 $1357$ 和 $2468$ 这两个数字求和。
4. 给定一个长度为 $n$ 的序列，每个位置的值是整数，且在 $[-n,n]$ 之间，求这个序列的最大子段和，这个问题需要用状态数为多少的自动机解决？请给出对应最小状态数的构造。
输入样例：$1,-2,3,-4,-5$，表示这个序列，答案为 $2$。
5. 给定一个长度为 $n$ 的序列 $a$ ，每个位置的值是整数，且在 $[-n,n]$ 之间，求最大的 $a_i+a_j+a_k$ 满足 $i<j<k$，这个问题需要用状态数为多少的自动机解决？请给出对应最小状态数的构造。
输入样例：$1,-2,3,-4,5$ 表示这个序列，答案为 $9$。 

### Solution

#### 问题一

信息存不下来，因为需要把第一个加数全部存下来才能在读入第二个数的时候做加法，所以不可能用 $\mathcal O(1)$ 个节点完成。

至少需要 $10^{n+1}$ 的状态，枚举所有可能的输入的位。

#### 问题二

无法处理进位问题，出现进位时至少需要存下有多少个连续的 $9$ 或者上一个数，所需状态数 $9n$ 。

#### 问题三

允许从低位到高位进行输出就可以。

（自动机的缺陷在于无法记录历史信息）

图灵机的定义：待补充

#### 问题四

维护前缀的最大子段和和最大后缀，状态数 $(N^2)^2=N^4$ 
但是这个做不了，因为需要一个自回归的状态，用于输出答案

#### 问题五

维护最大的 $a_i，a_i+a_j，a_i+a_j+a_k$ 。
实际上，存储 $O(1)$ 个信息的 DP 更像是自动机

(TBA)

### 思考题 2：RNN

定义以下计算过程叫做 RNN：

输入一个序列 $\{a_n\}$，你需要设计两个函数 $f,g$，定义序列 $\{b_n\}$ 为输出序列，$\{c_n\}$ 为隐藏状态，然后做以下计算过程：

```
for( i = 1 ; i <= n ; i++ ){
    c[i]=f(c[i-1],a[i]);
    b[i]=g(c[i]);
}
```

本题所有整数定义为 `int` 变量。
这里的 `c[i]` 可以不是一个整数，而是多个整数构成的一个结构体，每个 `c[i]` 的结构体需要是同样的结构。

这里的 `b[i]` 可以是空。 

1. 如果我们想让输出序列满足 $b_i=a_i$，请构造一组f,g函数.
2. 如果我们想让输出序列满足 $b_i=a_{n+1-i}$，可以实现吗？
3. 如果我们想让输出序列满足对 $i$ 在 $[n+1,2n]$ 之间，$b_i=a_{2n+1-i}$，循环条件从 `i<=n` 改为 `i<=2*n`，则每个 $c_i$ 对应的结构体需要至少多少空间？
4. 给定一个长度为 $n$ 的序列，每个位置的值是整数，且在 $[-n,n]$ 之间，求这个序列的最大子段和，对于这个问题，每个 $c[i]$ 对应的结构体需要至少多少空间？
输入样例：$1,-2,3,-4,-5$，表示这个序列，答案为 $2$。
5. 给定一个长度为 $n$ 的序列 $a$，每个位置的值是整数，且在 $[-n,n]$ 之间，求最大的 $a_i+a_j+a_k$ 满足 $i<j<k$，对于这个问题，每个 $c_i$ 对应的结构体需要至少多少空间？
输入样例：$1,-2,3,-4,5$，表示这个序列，答案为 $9$。
6. 给定一个状态数为 $n$ 的自动机，能否构造出 $f,g$（当然你得构造出 $c_i$ 的结构体），使得对于任意的输入，对应的 RNN 和该自动机的输出都是等价的？此时每个 $c_i$ 对应的结构体需要至少多少空间？
7. 给定一个 $c_i$ 对应的结构体占用 $n$ 个整数的 RNN，其 $f,g$ 是已知的，能否构造出一个自动机，使得对于任意的输入，对应的 RNN 和该自动机的输出都是等价的？此时这个自动机需要至少多少个状态？

#### 问题 1

比较显然，使 $c_i\gets a_i$ 为 $f$，$b_i\gets c_i$ 为 $g$ 即可。

#### 问题 2

倒着输出。

在把 $a$ 序列读完之前无法做到倒着输出，然而等 $a$ 读完的时候已经没有机会把答案记录下来了。

#### 问题 3

这里解决了第二问的问题。我们需要把 $[1,n]$ 的 $a$ 倒着放到 $[n+1,2n]$ 的 $b$ 里面。我们只需要把隐藏状态 $c$ 设为一个栈就可以了。

容易说明空间复杂度必须是 $\mathcal O(n)$ 的。我们必须要存下所有 $a$ 才能得到答案，换句话说答案的信息量是 $\mathcal O(n)$ 的。

#### 问题 4

每次加一个数维护答案，那么显然需要再用一个东西维护后缀最大值。

那这就和在线 dp 差不多了……直接做就可以。需要 $2$ 个 `int` 的空间。

#### 问题 5

维护当前位置之前选一个、选两个、选三个的答案，进行 dp 状转移即可，和问题 4 是类似的。

需要 $3$ 个 `int` 的空间。

#### 问题 6

考虑怎么把自动机等价转化成 RNN。

考虑自动机上 $x\rightarrow^\theta y$。不妨令 $c_{i-1}=x,a_i=\theta,c_i=y$。那么 $f$ 就形如一堆特判（如果 $(a_i,c_i)$ 为 $(\theta,x)$ 就返回 $y$）。

考虑我们只需要维护现在的 $c_i$ 是多少，换句话说 $c$ 就是一个 `int` 就够了。于是我们可以把一个 $n$ 个点的自动机上的每个节点用二进制编号转化成 $\log n$ bit 的 RNN。

#### 问题 7

考虑怎么可以把一个 RNN 转化成自动机。考虑隐藏状态有 $n$ 个 bit，那么就有 $2^n$ 种状态。那么我们只能进行状态打表，记录所有可能的 $c_i$ 在自动机上用 $a_i$ 转移。

于是 $\mathcal O(n)$ 的 RNN 变成了 $\mathcal O(2^n)$ 的自动机。可以发现这和问题 6 的结论恰好互逆，这就是**双向规约**。

#### 科普：RNN

递归神经网络。

例如自然语言处理。我们把 $c_i$ 的隐藏状态设置成一个位置的上文，用神经网络拟合，那么我们可以根据在训练数据中下一位的概率决定下一位。

## 2024.10.12 DP 优化

序文： DP 优化有很多种，减少状态数，数据结构维护转移，决策单调性等

1. CF833B

考虑设状态 $f[i][j]$ 表示前 $i$ 个被划分成 $j$ 块的最大权值。

考虑该状态的转移，发现转移是满足四边形不等式的，于是转移拥有决策单调性。

另一种证明：最大值是满足区间可加性的。对于两个区间 $[l,r]$ 和 $[l,r+1]$ ，设 $max$ 为 $[l,r]$ 中的最大值，那么在 $r$ 右移一位时，要么最大值不变，要么最大值变为 $r+1$ 上的元素，换句话说，在 $l$ 不变时，$max$ 随着 $r$ 的右移单调不降；两个区间同时加一个数 $x$ 后同理。所以 $f[i][j]$ 转移过程中是满足单调性的。

基于决策单调性，考虑分治。

由于答案单调，所以我们可以二分，设现在等待转移的区间为 $[l,r]$ ，可以转移过来的决策所在区间为 $[ql,qr]$ ，那么对于每一次查找，我们可以定义一个 $mid$ 为 $l,r$ 的中点，然后递归求解。

另一种做法：很显然，这个转移是可以用线段树维护的。对于颜色的贡献，考虑一种颜色能够产生贡献的范围，为他上一次出现的位置到他当前的位置，产生贡献为 $1$ ，可以使用线段树区间加，给 $pre[i] \sim i$ 都加上 $1$ ，从 $1$ 到 $n$ 进行枚举，逐渐进行上面的操作，每次换下一层的时候重构线段树

2. ARC108E

定义 $f[l][r]$ 表示钦定 $l\sim r$ 内选了 $l$ 和 $r$ 的前提下，区间 $(l, r)$ 内的贡献。转移的时候我们去找下标在 $l\sim r$ ，值域在 $a[l] \sim a[r]$ 的合法转移点 p 。

设 $k$ 为 $p$ 的数量。转移方程： $f[l][r]=\frac{1}{k}\times(f[l][p]+f[p][r])+1$ 。

于是我们将区间长度从小到大枚举转移，同时维护 $a[i]$ 对应的 $f[l][i]$ 和 $f[i][r]$ 。

### 决策单调性

四边形不等式可简记为：交叉小于包含。

存在序列 $a$ ，将其分成 $k$ 段，每段贡献为 $sum^2$ 。

$f[i][j]=\max_{x \leq i}(f[x][j-1]+(s[i]-s[x])^2)$

容易发现 $f[i+1][j] \geq f[i][j]$ ，这说明决策点右移了。

对于这题而言：

$(a, c), (b, d): (X+Y)^2+(Y+Z)^2$
$(a, d), (b, c): (X)^2+(X+Y+Z)^2$

做差得 $Y^2$ 和 $X^2+2XZ$ 。

观察可得， $b$ 会在某个位置之后优于 $a$ ，且 $b$ 在该位置之后会一直优于 $a$ 。

基于决策单调性，我们可以进行二分和分治（即通过已知决策点来推出其余决策点，减少无用时间）

3. CF321E

 $w(x, y)$ 表示现在已经决定了从 $x$ 到 $y$ 的狐狸的归宿时的最小怨气值。容易发现把 $l \sim r$ 放在一起的怨气值等于输入矩阵内三个顶点分别为 $(l, l), (l, r), (r, l)$ 的等腰直角三角形内值的总数。

四边形不等式推得决策单调性

对于一个平面函数一定都可以进行差分

对于 $w(x, y)$ ，我们可以令 $a(x, y)=w(x, y)+w(x-1, y-1)-w(x-1, y)-w(x, y-1)$ 。

这样我们可以用 $a$ 的区间和来表示 $w$ 。

发现 $w$ 满足四边形不等式只能使 $a$ 是恒为正或恒为负的

4. P9338

发现 $=k$ 和 $≤k$ 其实是等价的，先考虑对于一个确定的串，怎样划分能够使得子序列的数量尽量少。

画出一个 $N\times N$ 的折线图，出现 $A$ 往上，出现 $B$ 往右，发现不能有拐点出现在折线下，有则将其补上来，如此保证一定能划分完全。

设 $w(l,r)$ 为区间 $[l,r]$ 对应拐弯，即从 $(l,l)$ 走到 $(r,r)$ 的代价，假设原点坐标是 $(1,1)$ 。那么现在问题相当于是要划分成 $k$ 个区间，最小化代价和。

存在决策单调性，但用决策单调性不太好做。考虑给 $w(l,r)$ 一个更好的表征：设 $t_i$ 表示第 $i$ 向右前向上的次数，$pre_i$ 表示 $t_i$ 的前缀和，$cnt_i$ 和 $sum_i$ 分别表示满足 $t_j≤i$ 的 $j$ 的个数和 $t_j$ 的和，这些都容易 $O(n)$ 预处理。那么 $w(l,r)=(cnt_{r−1}−l+1)×(r−1)−sum_{r−1}+pre_{l-1}$ 。可以拆开用斜率优化。

tip.一个二元函数（双线性函数）一定满足四边形不等式

### 研讨

1. CF755D

注意到二阶差分只有 $0$ 和 $1$ ，这是因为每次多交的边最多只有 $1$ 条。

但这跟正解没关系。

我们可以用树状数组维护在一条线段的左右部分存在多少连线。

但其实我们也可以发现，这个边转一下最多加 $1$ 条边，研究一下在什么情况下边数会 $+1$ 

2. CF1654E

考虑根号分治。

公差 $<\sqrt{n}$ 时，枚举公差并算出每个公差对应的首项。

公差 $>\sqrt{n}$ 时，枚举每个数字对应的等差数列前面 $\sqrt{n}$ 位的数字

3. CF283C

把表示序关系的 DAG 画出来，发现这是一条链。

对于 $i$ 号硬币，我们可以把后面那些点的贡献合并，变成一种新的硬币

4. P10612

有点神金，没听到他们在讲什么，总之就是一下子就炸锅了。

5. P10218

白兰了不想听（有 abc ）

6. lca省选营入营测试T2

白兰了不想听（有 abc ）

### 2024.10.14 模拟赛

#### T1

由于背包大小不递减的原因，在取走 $n$ 个物品的前提下，后 $n$ 个最大的背包一定是最有用的，因此题目中 $m$ 较大的数据范围形同虚设。在此基础上，可以设计出一个 $n^3$ 的 dp 状态：$f_{i,j,k}$ 表示前 $i$ 个物品，使用到了第 $j$ 个背包，这个背包容量还剩 $k$ 的最大价值和。时间复杂度 $\mathcal{O}(n^3)$。

#### T2

有点烦人的题目，涉及到数据结构、贪心以及一定的性质推导。好在结论非常好猜。题解涉及到的结论的证明会在题解未尾给出。

如果 $k$ 是负数或者 $0$ 那么显然一眼丁真，答案就是 $0$ 或者无解。接下来只考虑 $k$ 是正数的情况。

首先如果权值全都是正数那该怎么做。显然我们最终构造出的排列一定恰好只有一个大环和若干个大小为 $1$ 的自环，这个大环即是我们要找的权值和大于等于 $k$ 的环。那么一个猜测是如果我钦定区间 $[l,r]$ 里的所有元素需要被包含进大环中，那么构造一个逆序对个数最小的大环方式即为 $\{1,2\cdots l+1,l+2\cdots r,l\cdots n-1,n\}$ 这样构造。它的花费正好是区间长度减 $1$。显然从这个大区间中扣掉一些元素反而会增大花费，所以选择一个整区间一定最优。使用双指针即可。

然后我们发现会有负数权值，所以选择一个区间之后可能会舍弃一些点，这也意味着我们选择的环会构成一个集合。当然，我们如法炮制上面的构造，即假设我们选择了有序数组 $p$ 这些位置的共 $x$ 个元素，那么就能构造环 $\{p_2,p_3,……,p_x,p_1\}$。由于构造的环显然要跨过每个被舍弃的点两次，所以这样的构造仍然达到了理论下界。可以发现每个被舍弃的点会额外贡献一次。虽然我们是不能舍弃最左和最右的点的，但因为我们如果进行了这样的操作那么一定能找到一个严格不劣的合法操作，所以我们默认这样的舍弃也是可行的。

有了理论基础就可以借助扫描线和念心来解决这个问题了。如果固定区间，那么每次只要舍弃权值最小的点即可。但是这样做复杂度过高。枚举右端点并枚举所选择的后缀，由于区间的延长会使得区间长度减一这条贡献增大，所以我们舍弃的点的数量一定会严格减小。我们找到第一个可能满足条件的后缀（即正数和大于等于 $k$）并用贪心求出至少要舍弃多少点，接下来不断加入元素并查验是否能舍弃更少的点使得区间满足条件。在这一过程中使用优先队列维护所有可能被舍弃的点即可达到 $\mathcal{O}(n^2 \log n)$ 的复杂度。

结论证明：使一个长度为 $n$ 的排列形成一个大环所需要花费的最小逆序对数是 $n-1$。记 $f(x)$ 表示长度为 $x$ 的排列形成一个大环所需要花费的最小逆序对数，我们可以归纳证明。显然 $f(1)= 0,f(2)= 1,f(3)= 2$。对于 $n\ge 4$，我们假设 $f(x)=x-1$ 对于 $x<n$ 成立。假设 $1$ 在排列中所处的位置为 $i$（注意到 $i$ 不可能等于 $1$），那么其至少为排列贡献了 $i-1$ 数量的逆序对。将 $1$ 删除后，排列会形成一个大小至少为 $n-i+1$ 的大环（读者自证不难），所以 $f(n)> f(n-i+1)+i-1$，即 $f(n)>n-1$，由于构造一组 $f(n)=n-1$ 的答案是简单的，所以 $f(n)=n-1$ 得证。

#### T3

题意：给定一个有向图，$q$ 组询问 $(s,t,k)$，求出 $s\to t$ 字典序最小的路径上的第 $k$ 个点。需要判断路径无限长、不存在第 $k$ 个点、不存在路径。$1\le n\le2000,1\le m\le 5000,1\le q\le 5\times 10^4$。

考虑先跑一遍连通性，这样不存在路径是容易判断的。

然后考虑一个暴力。我们每次一定是从 $s$ 开始，寻求一个编号最小的点且仍然可以抵达 $t$ 的点，然后走过去。这样循环走 $k$ 次就是答案。

一眼倍增。考虑我们提前预处理出每对 $(s,t)$ 从 $s$ 开始第 $1$ 步需要走向哪个点，很容易进行类似 LCA 的转移求出 $(s,t)$ 走 $2^i$ 步的位置。预处理出来之后求答案和转移类似，也是容易的。

特别地，转移的时候我们特判走不到或者走到 $t$ 的情况。已经走到 $t$ 之后的状态和走不到的状态都应该设置为不存在。如果求答案时用到了不存在的状态，就说明无解。

再考虑路径无限长怎么判断。可以发现，如果字典序最小的路径是有限长的，则一定不会两次经过同一个点（否则下一步也是相同的，就陷入环了），所以我们直接查询路径上是否存在走了 $n+1$ 个点的状态，如果存在就说明路径无限长。

这样就做完了。连通性不需要缩点和 topo，直接 dfs 就能做到 $\mathcal O(nm)$。总时间复杂度 $\mathcal O((n^2+q)\log n+nm)$。

#### T4

[JOISC2015 D2T2 备用钥匙](https://www.luogu.com.cn/problem/AT_joisc2015_f)

我们容易想到把时间轴画出来，然后发现每段时间能否关门只与时间段两侧事件的人是否有钥匙、进门还是出门有关。考虑这两个人分别是 $i,j$，不妨讨论一下所有的情况。

- $i$ 进门，$j$ 进门。$i$ 能关门当且仅当 $j$ 有钥匙。
- $i$ 进门，$j$ 出门。一定能关门。
- $i$ 出门，$j$ 进门。$i$ 能关门当且仅当 $i,j$ 都有钥匙。
- $i$ 出门，$j$ 出门。$i$ 能关门当且仅当 $i$ 有钥匙。

可以发现，我们的贡献形如某个人有钥匙就贡献，或者某两个人有钥匙就贡献。结合这个题浓重的 dp 味，我们可以自然想到，$i$ 有钥匙就贡献的部分，就直接垒到 $i$ 上，$i,j$ 有钥匙就贡献的部分，应该给 $i\to j$ 连边（很自然吧，按照时间顺序连边）之后放到边上。

类似那天研讨讲的 CF283C，我们发现这个图上每个点至多是一条入边一条出边，并且显然不可能存在环，所以就应该是一堆链了。我会 dp！

考虑显然的状态：$f_{i,j,0/1}$ 表示前 $i$ 个人有 $j$ 把钥匙，第 $i$ 个人有没有的最大贡献和。转移是比较显然的。

对于每条链跑出来这个之后背包一遍就可以了。写的时候需要精细实现一下，只需要对链长个物品做考虑，并且枚举状态只需要枚举到前面的链长和就足够了。可以发现这个 dp 实际上是形如子树合并，每一对不相同链中的点对都做贡献，时间复杂度是 $\mathcal O(n^2)$ 的。

总时间复杂度 $\mathcal O(n^2)$。

## 2024.10.16 树

树很复杂。

### 树本身

#### P6118 [JOI 2019 Final] 珍しい都市

> 题意：所有树点有一个颜色，计算距离某个点的距离独一无二的所有点中出现的颜色数量。要对所有点求解。

首先一个显然的结论，距离 $i$ 独一无二的点来自于一条链，并且这条链一定包含最远的点。如果有多个距离它最远的点，任意一条都是满足的。

那么不妨考虑把直径找出来。

考虑点 $i$ 距离最远的点一定来自于直径的一端。容易想到我们去统计某个端点对所有点的贡献，做两次就可以了。尤其注意到两边的答案具有覆盖性，也就是短一些的那一端答案总是 $0$，所以我们可以不区分哪个是真正的最远的端点（不合法不优），直接两端都做取 $\max$ 就可以了。

我们以一个端点为根，我们要对于每个点都快速统计出根到它的链上合法点的颜色数。考虑我们只要能维护所有这种点的添加删除就能类似莫队地实现数颜色。

不妨先长剖，这样每个点上深度最深的儿子成为重儿子。

考虑每个点上对到根的链产生最大影响的其实是重儿子。距离小于等于重儿子深度的点都会变成不合法的点，并且这种影响会延续到轻儿子中。也就是说，对轻儿子里的所有点，这些点也是不合法的，可以直接继承。

然后考虑重儿子，那就是距离小于等于最深轻儿子深度的点都会变成不合法的点了，重儿子里面的所有点也会继承这个。

此时你发现重儿子对不合法点的影响被轻儿子对不合法点的影响完全覆盖。所以说我们只要先做重儿子再做轻儿子，就可以很简单地维护合法点集，删掉的点不用再加回来了。

我们扫完之后就能计算这个点本身的贡献了。很容易证明子树中的点不会干涉到子树根的合法点，所以直接查就行了。

可以用一个 dfs 栈维护合法点集。考虑这个东西因为是按顺序的根到自己的一条链上的点集，应该是一个单调栈状物，从上至下距离越来越近，所以很容易维护，需要删点的的时候直接暴力弹栈就行了。

需要特别考虑一下这个点本身。这个点本身不受轻重儿子限制影响，所以需要特意加入，回溯的时候如果发现父亲在栈顶也要特意删掉。

每个点的进栈次数是度数次的，所以总时间复杂度 $\mathcal O(n)$。

很精妙的题。

[Code](https://loj.ac/s/2180181)

#### LOJ#6020. 「from CommonAnts」寻找 LCT

similar to [#6042.「雅礼集训 2017 Day7」跳蚤王国的宰相](https://loj.ac/p/6042)

一道乍一看没有什么思路的好题。为啥 LCA 这么强悍。

显然，自己连的边不会再删掉。所以删的都是原树边。

考虑操作的形态一定是，割掉一个子树把它直接接到根上，这是显然的。

考虑找出原树的重心，注意到任何一个大于一半的子树一定包含重心（如果不包含重心，那么它的大小一定小于等于重心在原来的任何一个子树，因为我们不会把两个子树接到一起）。

那么贪心地，我们肯定是割掉重心的前 $k$ 大子树，使得最后包含重心的连通块尽可能小。可以注意到割掉的子树一定不产生坏影响，因为它们的大小一定都小于等于一半。

不妨以重心为根，考虑重心的每个子树里的点。那么要割肯定是割掉排除这个所在子树以外的其他子树的前 $k$ 大，因为你把它

#### P5666 [CSP-S2019] 树的重心

一棵树的重心一定在根开始的那条重链上。

### 研讨

by After_light

文字版题解：
1. https://www.luogu.com.cn/article/ajwwzc6g 
2. https://www.luogu.com.cn/article/kxo609b1
3. https://www.luogu.com.cn/article/2rt84led
4. https://www.luogu.com.cn/article/difp0s8f
5. https://www.luogu.com.cn/article/w9cpy9hf

注：这些题除了最短路那道基本上网上都可以搜到不少题解，所以可以自行选择更为优质的题解。

#### 一个神秘的题

waiting...

#### 约瑟夫环求出局者序列

考虑第一个出局的人是编号第 $k$ 小的，第二个人是编号第 $2k-1$ 小的，以此类推。线段树上二分即可。

#### ABC155F

首先显然差分，区间修改改成单点异或 $1$ 掉 $(l,r+1)$。我们不妨直接连出一张图。

然后我们容易发现这张图上的环都是没用的，所以抽一个生成森林就行了。

#### ABC138F

显然 $x,y$ 的最高位必须相同。

于是左边可以转成 $y-x$，考虑 $y-x=x\oplus y$，显然这说明 $y$ 必须是 $x$ 的超集。

然后显然是数位 dp……

考虑 dp 掉 $y$，设 $f_{i,b_1,b_2}$ 表示前 $i$ 高位，是否抵达 $L$ 的下界，是否抵达 $R$ 的上界的方案数。

#### LOJ#10202. 「一本通 6.2 练习 5」樱花

#### P9220「TAOI-1」椎名真昼

诈骗题。首先如果 A 操作了一个点，那么 B 就把它干回去就行了。换句话说，A 必须一步获胜，否则 A 赢不了。

考虑 B 怎么胜利。同理，B 必须在第二步一步获胜，否则 B 也赢不了。容易发现，需要：

- 白点不存在可达的黑点。
- 黑点不能不经过其他白点地到达两个白点。
- 不存在两个有黑点的连通块。

#### P2148 E&D

别打表你那 SG 函数了

#### P2490 [SDOI2011] 黑白棋

考虑每个白棋子和黑棋子中间的间隔，A 只能把白棋向右压缩，B 只能把黑棋向左压缩，当间隔为 $0$ 时这个间隔就报废了。

我们发现这很像取石子啊！有很多堆石子，每次只能拿 $[1,d]$ 堆石子中的一个，拿不了的人输。

当成拓展 Nim 游戏做。

#### P9133 [THUPC 2023 初赛] 大富翁