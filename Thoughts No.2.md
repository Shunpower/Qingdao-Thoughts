Developed by Shunpower, StayAlone, Zelotz, H_Z_J, LPhang, WaterSun, harmis_yz

[Github - Shunpower - Qingdao Thoughts Repository](https://github.com/Shunpower/Qingdao-Thoughts/)

## 思考题

### 思考题 1：广义自动机

补充：自动机定义为输入一个序列，从左往右读入字符，每读入一个字符需要决定输出常数个字符（可以不输出）。

1. 给定一个长度为 $n$ 的加法算式，求这两个数字的和，这个问题是否可以用一个状态数 $O(1)$ 的自动机解决？如果可以，请构造出该自动机。
输入样例：$114514+1919810=$。 
2. 给定两个长度为 $n$ 的数字，求这两个数字的和，如果将两个数字分别从最高位开始交替输入，这个问题是否可以用一个状态数 $O(1)$ 的自动机解决？如果可以，请构造出该自动机。
输入样例：$12345678$，表示将 $1357$ 和 $2468$ 这两个数字求和。
3. 给定两个长度为 $n$ 的数字，求这两个数字的和，如果将两个数字分别从最低位开始交替输入，这个问题是否可以用一个状态数 $O(1)$ 的自动机解决？如果可以，请构造出该自动机。
输入样例：$87654321$，表示将 $1357$ 和 $2468$ 这两个数字求和。
4. 给定一个长度为 $n$ 的序列，每个位置的值是整数，且在 $[-n,n]$ 之间，求这个序列的最大子段和，这个问题需要用状态数为多少的自动机解决？请给出对应最小状态数的构造。
输入样例：$1,-2,3,-4,-5$，表示这个序列，答案为 $2$。
5. 给定一个长度为 $n$ 的序列 $a$ ，每个位置的值是整数，且在 $[-n,n]$ 之间，求最大的 $a_i+a_j+a_k$ 满足 $i<j<k$，这个问题需要用状态数为多少的自动机解决？请给出对应最小状态数的构造。
输入样例：$1,-2,3,-4,5$ 表示这个序列，答案为 $9$。 

### Solution

#### 问题一

信息存不下来，因为需要把第一个加数全部存下来才能在读入第二个数的时候做加法，所以不可能用 $\mathcal O(1)$ 个节点完成。

至少需要 $10^{n+1}$ 的状态，枚举所有可能的输入的位。

#### 问题二

无法处理进位问题，出现进位时至少需要存下有多少个连续的 $9$ 或者上一个数，所需状态数 $9n$ 。

#### 问题三

允许从低位到高位进行输出就可以。

（自动机的缺陷在于无法记录历史信息）

图灵机的定义：待补充

#### 问题四

维护前缀的最大子段和和最大后缀，状态数 $(N^2)^2=N^4$ 
但是这个做不了，因为需要一个自回归的状态，用于输出答案

#### 问题五

维护最大的 $a_i，a_i+a_j，a_i+a_j+a_k$ 。
实际上，存储 $O(1)$ 个信息的 DP 更像是自动机

(TBA)

### 思考题 2：RNN

定义以下计算过程叫做 RNN：

输入一个序列 $\{a_n\}$，你需要设计两个函数 $f,g$，定义序列 $\{b_n\}$ 为输出序列，$\{c_n\}$ 为隐藏状态，然后做以下计算过程：

```
for( i = 1 ; i <= n ; i++ ){
    c[i]=f(c[i-1],a[i]);
    b[i]=g(c[i]);
}
```

本题所有整数定义为 `int` 变量。
这里的 `c[i]` 可以不是一个整数，而是多个整数构成的一个结构体，每个 `c[i]` 的结构体需要是同样的结构。

这里的 `b[i]` 可以是空。 

1. 如果我们想让输出序列满足 $b_i=a_i$，请构造一组f,g函数.
2. 如果我们想让输出序列满足 $b_i=a_{n+1-i}$，可以实现吗？
3. 如果我们想让输出序列满足对 $i$ 在 $[n+1,2n]$ 之间，$b_i=a_{2n+1-i}$，循环条件从 `i<=n` 改为 `i<=2*n`，则每个 $c_i$ 对应的结构体需要至少多少空间？
4. 给定一个长度为 $n$ 的序列，每个位置的值是整数，且在 $[-n,n]$ 之间，求这个序列的最大子段和，对于这个问题，每个 $c[i]$ 对应的结构体需要至少多少空间？
输入样例：$1,-2,3,-4,-5$，表示这个序列，答案为 $2$。
5. 给定一个长度为 $n$ 的序列 $a$，每个位置的值是整数，且在 $[-n,n]$ 之间，求最大的 $a_i+a_j+a_k$ 满足 $i<j<k$，对于这个问题，每个 $c_i$ 对应的结构体需要至少多少空间？
输入样例：$1,-2,3,-4,5$，表示这个序列，答案为 $9$。
6. 给定一个状态数为 $n$ 的自动机，能否构造出 $f,g$（当然你得构造出 $c_i$ 的结构体），使得对于任意的输入，对应的 RNN 和该自动机的输出都是等价的？此时每个 $c_i$ 对应的结构体需要至少多少空间？
7. 给定一个 $c_i$ 对应的结构体占用 $n$ 个整数的 RNN，其 $f,g$ 是已知的，能否构造出一个自动机，使得对于任意的输入，对应的 RNN 和该自动机的输出都是等价的？此时这个自动机需要至少多少个状态？

#### 问题 1

比较显然，使 $c_i\gets a_i$ 为 $f$，$b_i\gets c_i$ 为 $g$ 即可。

#### 问题 2

倒着输出。

在把 $a$ 序列读完之前无法做到倒着输出，然而等 $a$ 读完的时候已经没有机会把答案记录下来了。

#### 问题 3

这里解决了第二问的问题。我们需要把 $[1,n]$ 的 $a$ 倒着放到 $[n+1,2n]$ 的 $b$ 里面。我们只需要把隐藏状态 $c$ 设为一个栈就可以了。

容易说明空间复杂度必须是 $\mathcal O(n)$ 的。我们必须要存下所有 $a$ 才能得到答案，换句话说答案的信息量是 $\mathcal O(n)$ 的。

#### 问题 4

每次加一个数维护答案，那么显然需要再用一个东西维护后缀最大值。

那这就和在线 dp 差不多了……直接做就可以。需要 $2$ 个 `int` 的空间。

#### 问题 5

维护当前位置之前选一个、选两个、选三个的答案，进行 dp 状转移即可，和问题 4 是类似的。

需要 $3$ 个 `int` 的空间。

#### 问题 6

考虑怎么把自动机等价转化成 RNN。

考虑自动机上 $x\rightarrow^\theta y$。不妨令 $c_{i-1}=x,a_i=\theta,c_i=y$。那么 $f$ 就形如一堆特判（如果 $(a_i,c_i)$ 为 $(\theta,x)$ 就返回 $y$）。

考虑我们只需要维护现在的 $c_i$ 是多少，换句话说 $c$ 就是一个 `int` 就够了。于是我们可以把一个 $n$ 个点的自动机上的每个节点用二进制编号转化成 $\log n$ bit 的 RNN。

#### 问题 7

考虑怎么可以把一个 RNN 转化成自动机。考虑隐藏状态有 $n$ 个 bit，那么就有 $2^n$ 种状态。那么我们只能进行状态打表，记录所有可能的 $c_i$ 在自动机上用 $a_i$ 转移。

于是 $\mathcal O(n)$ 的 RNN 变成了 $\mathcal O(2^n)$ 的自动机。可以发现这和问题 6 的结论恰好互逆，这就是**双向规约**。

#### 科普：RNN

递归神经网络。

例如自然语言处理。我们把 $c_i$ 的隐藏状态设置成一个位置的上文，用神经网络拟合，那么我们可以根据在训练数据中下一位的概率决定下一位。

### 思考题 3：合并复杂度问题

一开始你有 $n$ 个集合，每个集合中有 $1$ 个不同的元素，你需要逐步合并这些集合，每次可以将两个集合合并为一个集合，最终剩下 $1$ 个集合，这个集合中有 $n$ 个元素。

1. 设集合大小为 $a,b$，合并的代价为 $a\times b$，求对于所有可能的合并的操作序列，总代价最大和最小分别是多少？
2. 设集合大小为 $a,b$，合并的代价为 $\min(a,b)$，求对于所有可能的合并的操作序列，总代价最大和最小分别是多少？
3. 设集合大小为 $a,b$，合并的代价为 $a+b$，求对于所有可能的合并的操作序列，总代价最大和最小分别是多少？
4. 给定常数 $k$，在合并过程中 $k$ 始终不变，设集合大小为 $a,b$，合并的代价为 $\min(a,k)\times \min(b,k)$，求对于所有可能的合并的操作序列，总代价最大和最小分别是多少？
5. 如果你可以自己构造合并顺序，设集合大小为 $a,b$，合并的代价为 $a+b$，如何构造可以让合并代价最小？最大呢？
6. 假设一开始第 $i$ 个集合中有 $a_i$ 个元素，你可以自己构造合并顺序，设集合大小为 $a,b$，合并的代价为 $a+b$，如何构造可以让合并代价最小？
7. 假设一开始第 $i$ 个集合中有 $x_i$ 个元素，其中所有 $x_i$ 的和等于 $n$。如果每次可以选择三个大小为 $a,b,c$ 的集合合并，代价是 $\min(a,b,c)$，得到的集合大小是 $\max(a+b,a+c,b+c)$，最终要得到 $\le2$ 个集合。如何构造让合并代价尽可能小？此时合并代价是多少？
8. 假设一开始第 $i$ 个集合中有 $x_i$ 个元素，其中所有 $x_i$ 的和等于 $n$，有部分集合是空的。如果每次可以选择两个大小为 $a,b$ 的集合合并，合并代价是 $\min(a,b,|a-b|)$。求在最坏的输入 ${x_i}$ 下，如何构造让合并代价尽可能小？此时合并代价是多少？

### Solution

#### 问题 1

不难发现，最大和最小值相同。均为 ${n\choose{2}}$。

#### 问题 2

最大和最小都是 $n\log n$ 的（启发式合并）。

#### 问题 3

每次每次选 $2$ 个最小的，可以得到总代价最大为 $n\log n$。同理，每次选 $2$ 个最大的，得到最小总代价为 $n^2$。

#### 问题 4

这个等价于树上背包问题。不难发现，对于 $siz\le k$ 的子树，每个点的贡献不超过 $k$。而对于 $siz >k$ 的子树，每个点的贡献不超过 $\frac{n}{k}$。那么复杂度为 $O(\frac{n}{k}\times k^2)$，所以最大和最小都是 $nk$ 的。

#### 问题 5

构造见问题 $3$。

#### 问题 6

还是每次取最小的，复杂度为 $O(n\log n)$。注意，这个的复杂度不一定比问题 $5$ 更优。

#### 问题 7

能够发现，最后的代价为删除的集合的大小和。那么我们需要最大化剩下的集合。对于两个大的集合于一个小的集合，因为我们删除的集合数量一定。所以每次选一个最小的集合与两个最大的集合一定最优。

因为操作实际上相当于消耗掉一个小的与一个大的。所以合并代价的界为 $\frac{n}{2}$。也就是小的集合的和。

#### 问题 8

可以证明这个是线性的。现在考虑在 $[m,2m]$ 的集合合并。将它们按照大小排序之后，相邻两个合并一定是最优的。那么这么倍增下去，每个点最多被覆盖一次，所以是线性的。当所有的 $x_i$ 都为 $1$ 时，该合并方式在每个 $2_i$ 时最多产生 $1$ 的代价。所以是 $\operatorname{popcount}(n)$。也就是说代价在 $[\operatorname{popcount}(n), n]$ 之间。

## 思考题 4：限制生成树

基础问题：给定一个 $n$ 个点 $m$ 条边的无向图，边有边权，求出其最小生成树。

1. 现在有些边是红色，求恰好含有一条红色边的最小生成树的权值。

2. 求恰好有 $k$ 条红色边的最小生成树的权值。

3. 设 $g(k)$ 表示恰好 $k$ 条红色边的最小生成树，证明 $g(k)$ 是凸函数。也许你已经知道了这个算法叫「WQS 二分」，但他的集训队论文中没有给出凸函数的证明。提示：可以定义 $f(k)=g(k)-g(k-1)$，尝试结合 1. 中破圈的思路证明 $f$ 的单调性。

4. 尝试根据 2. 中方法给出一个具体的构造 $k$ 条红色边的方案。你会发现这其实并不显然。直接构造的问题出在哪里？在凸函数图上表现为什么形式？

5. 证明：若一个图边权互不相同，则该图的最小生成树唯一。

6. 更进一步地，证明若一个图有多种最小生成树，那么所有最小生成树方案中每种边权的数量相等。

7. 由 6. 知，构造方案时只需特殊考虑边权为某一特定值 $w$ （其实就是二分得到的结果）的普通边和红色边，从而给出一种具体构造方案。

### Solution

#### 问题 1

$kruskal$ 之后换边即可

#### 问题 2

wqs 二分

#### 问题 3

判定凸函数：对于任意两点连线，中间的点都在下面。

判定凸函数：二阶导函数（导数是实数域上的差分（斜率））为非负数。

#### 问题 4

构造时，我们可以考虑在二分的过程中进行构造。

但我们会发现一个问题：二分只能得到合法方案的端点，而我们找合法方式使用一条直线去交一个凸函数，可是直线与凸函数会有多个交点

#### 问题 5

对于两个最小生成树，考虑替换其中值最小的边，但是无法替换（他在说什么 /lh，没搞懂）。

#### 问题 6

与问题 5 类似。

通过该推论，我们可以分权值分批次的进行加边。

#### 问题 7

蚌埠住了。

## 2024.10.12 DP 优化

序文： DP 优化有很多种，减少状态数，数据结构维护转移，决策单调性等

1. CF833B

考虑设状态 $f[i][j]$ 表示前 $i$ 个被划分成 $j$ 块的最大权值。

考虑该状态的转移，发现转移是满足四边形不等式的，于是转移拥有决策单调性。

另一种证明：最大值是满足区间可加性的。对于两个区间 $[l,r]$ 和 $[l,r+1]$ ，设 $max$ 为 $[l,r]$ 中的最大值，那么在 $r$ 右移一位时，要么最大值不变，要么最大值变为 $r+1$ 上的元素，换句话说，在 $l$ 不变时，$max$ 随着 $r$ 的右移单调不降；两个区间同时加一个数 $x$ 后同理。所以 $f[i][j]$ 转移过程中是满足单调性的。

基于决策单调性，考虑分治。

由于答案单调，所以我们可以二分，设现在等待转移的区间为 $[l,r]$ ，可以转移过来的决策所在区间为 $[ql,qr]$ ，那么对于每一次查找，我们可以定义一个 $mid$ 为 $l,r$ 的中点，然后递归求解。

另一种做法：很显然，这个转移是可以用线段树维护的。对于颜色的贡献，考虑一种颜色能够产生贡献的范围，为他上一次出现的位置到他当前的位置，产生贡献为 $1$ ，可以使用线段树区间加，给 $pre[i] \sim i$ 都加上 $1$ ，从 $1$ 到 $n$ 进行枚举，逐渐进行上面的操作，每次换下一层的时候重构线段树

2. ARC108E

定义 $f[l][r]$ 表示钦定 $l\sim r$ 内选了 $l$ 和 $r$ 的前提下，区间 $(l, r)$ 内的贡献。转移的时候我们去找下标在 $l\sim r$ ，值域在 $a[l] \sim a[r]$ 的合法转移点 p 。

设 $k$ 为 $p$ 的数量。转移方程： $f[l][r]=\frac{1}{k}\times(f[l][p]+f[p][r])+1$ 。

于是我们将区间长度从小到大枚举转移，同时维护 $a[i]$ 对应的 $f[l][i]$ 和 $f[i][r]$ 。

### 决策单调性

四边形不等式可简记为：交叉小于包含。

存在序列 $a$ ，将其分成 $k$ 段，每段贡献为 $sum^2$ 。

$f[i][j]=\max_{x \leq i}(f[x][j-1]+(s[i]-s[x])^2)$

容易发现 $f[i+1][j] \geq f[i][j]$ ，这说明决策点右移了。

对于这题而言：

$(a, c), (b, d): (X+Y)^2+(Y+Z)^2$
$(a, d), (b, c): (X)^2+(X+Y+Z)^2$

做差得 $Y^2$ 和 $X^2+2XZ$ 。

观察可得， $b$ 会在某个位置之后优于 $a$ ，且 $b$ 在该位置之后会一直优于 $a$ 。

基于决策单调性，我们可以进行二分和分治（即通过已知决策点来推出其余决策点，减少无用时间）

3. CF321E

 $w(x, y)$ 表示现在已经决定了从 $x$ 到 $y$ 的狐狸的归宿时的最小怨气值。容易发现把 $l \sim r$ 放在一起的怨气值等于输入矩阵内三个顶点分别为 $(l, l), (l, r), (r, l)$ 的等腰直角三角形内值的总数。

四边形不等式推得决策单调性

对于一个平面函数一定都可以进行差分

对于 $w(x, y)$ ，我们可以令 $a(x, y)=w(x, y)+w(x-1, y-1)-w(x-1, y)-w(x, y-1)$ 。

这样我们可以用 $a$ 的区间和来表示 $w$ 。

发现 $w$ 满足四边形不等式只能使 $a$ 是恒为正或恒为负的

4. P9338

发现 $=k$ 和 $≤k$ 其实是等价的，先考虑对于一个确定的串，怎样划分能够使得子序列的数量尽量少。

画出一个 $N\times N$ 的折线图，出现 $A$ 往上，出现 $B$ 往右，发现不能有拐点出现在折线下，有则将其补上来，如此保证一定能划分完全。

设 $w(l,r)$ 为区间 $[l,r]$ 对应拐弯，即从 $(l,l)$ 走到 $(r,r)$ 的代价，假设原点坐标是 $(1,1)$ 。那么现在问题相当于是要划分成 $k$ 个区间，最小化代价和。

存在决策单调性，但用决策单调性不太好做。考虑给 $w(l,r)$ 一个更好的表征：设 $t_i$ 表示第 $i$ 向右前向上的次数，$pre_i$ 表示 $t_i$ 的前缀和，$cnt_i$ 和 $sum_i$ 分别表示满足 $t_j≤i$ 的 $j$ 的个数和 $t_j$ 的和，这些都容易 $O(n)$ 预处理。那么 $w(l,r)=(cnt_{r−1}−l+1)×(r−1)−sum_{r−1}+pre_{l-1}$ 。可以拆开用斜率优化。

tip.一个二元函数（双线性函数）一定满足四边形不等式

### 研讨

1. CF755D

注意到二阶差分只有 $0$ 和 $1$ ，这是因为每次多交的边最多只有 $1$ 条。

但这跟正解没关系。

我们可以用树状数组维护在一条线段的左右部分存在多少连线。

但其实我们也可以发现，这个边转一下最多加 $1$ 条边，研究一下在什么情况下边数会 $+1$ 

2. CF1654E

考虑根号分治。

公差 $<\sqrt{n}$ 时，枚举公差并算出每个公差对应的首项。

公差 $>\sqrt{n}$ 时，枚举每个数字对应的等差数列前面 $\sqrt{n}$ 位的数字

3. CF283C

把表示序关系的 DAG 画出来，发现这是一条链。

对于 $i$ 号硬币，我们可以把后面那些点的贡献合并，变成一种新的硬币

4. P10612

有点神金，没听到他们在讲什么，总之就是一下子就炸锅了。

5. P10218

白兰了不想听（有 abc ）

6. lca省选营入营测试T2

白兰了不想听（有 abc ）

### 2024.10.14 模拟赛

#### T1

由于背包大小不递减的原因，在取走 $n$ 个物品的前提下，后 $n$ 个最大的背包一定是最有用的，因此题目中 $m$ 较大的数据范围形同虚设。在此基础上，可以设计出一个 $n^3$ 的 dp 状态：$f_{i,j,k}$ 表示前 $i$ 个物品，使用到了第 $j$ 个背包，这个背包容量还剩 $k$ 的最大价值和。时间复杂度 $\mathcal{O}(n^3)$。

#### T2

有点烦人的题目，涉及到数据结构、贪心以及一定的性质推导。好在结论非常好猜。题解涉及到的结论的证明会在题解未尾给出。

如果 $k$ 是负数或者 $0$ 那么显然一眼丁真，答案就是 $0$ 或者无解。接下来只考虑 $k$ 是正数的情况。

首先如果权值全都是正数那该怎么做。显然我们最终构造出的排列一定恰好只有一个大环和若干个大小为 $1$ 的自环，这个大环即是我们要找的权值和大于等于 $k$ 的环。那么一个猜测是如果我钦定区间 $[l,r]$ 里的所有元素需要被包含进大环中，那么构造一个逆序对个数最小的大环方式即为 $\{1,2\cdots l+1,l+2\cdots r,l\cdots n-1,n\}$ 这样构造。它的花费正好是区间长度减 $1$。显然从这个大区间中扣掉一些元素反而会增大花费，所以选择一个整区间一定最优。使用双指针即可。

然后我们发现会有负数权值，所以选择一个区间之后可能会舍弃一些点，这也意味着我们选择的环会构成一个集合。当然，我们如法炮制上面的构造，即假设我们选择了有序数组 $p$ 这些位置的共 $x$ 个元素，那么就能构造环 $\{p_2,p_3,……,p_x,p_1\}$。由于构造的环显然要跨过每个被舍弃的点两次，所以这样的构造仍然达到了理论下界。可以发现每个被舍弃的点会额外贡献一次。虽然我们是不能舍弃最左和最右的点的，但因为我们如果进行了这样的操作那么一定能找到一个严格不劣的合法操作，所以我们默认这样的舍弃也是可行的。

有了理论基础就可以借助扫描线和念心来解决这个问题了。如果固定区间，那么每次只要舍弃权值最小的点即可。但是这样做复杂度过高。枚举右端点并枚举所选择的后缀，由于区间的延长会使得区间长度减一这条贡献增大，所以我们舍弃的点的数量一定会严格减小。我们找到第一个可能满足条件的后缀（即正数和大于等于 $k$）并用贪心求出至少要舍弃多少点，接下来不断加入元素并查验是否能舍弃更少的点使得区间满足条件。在这一过程中使用优先队列维护所有可能被舍弃的点即可达到 $\mathcal{O}(n^2 \log n)$ 的复杂度。

结论证明：使一个长度为 $n$ 的排列形成一个大环所需要花费的最小逆序对数是 $n-1$。记 $f(x)$ 表示长度为 $x$ 的排列形成一个大环所需要花费的最小逆序对数，我们可以归纳证明。显然 $f(1)= 0,f(2)= 1,f(3)= 2$。对于 $n\ge 4$，我们假设 $f(x)=x-1$ 对于 $x<n$ 成立。假设 $1$ 在排列中所处的位置为 $i$（注意到 $i$ 不可能等于 $1$），那么其至少为排列贡献了 $i-1$ 数量的逆序对。将 $1$ 删除后，排列会形成一个大小至少为 $n-i+1$ 的大环（读者自证不难），所以 $f(n)> f(n-i+1)+i-1$，即 $f(n)>n-1$，由于构造一组 $f(n)=n-1$ 的答案是简单的，所以 $f(n)=n-1$ 得证。

#### T3

题意：给定一个有向图，$q$ 组询问 $(s,t,k)$，求出 $s\to t$ 字典序最小的路径上的第 $k$ 个点。需要判断路径无限长、不存在第 $k$ 个点、不存在路径。$1\le n\le2000,1\le m\le 5000,1\le q\le 5\times 10^4$。

考虑先跑一遍连通性，这样不存在路径是容易判断的。

然后考虑一个暴力。我们每次一定是从 $s$ 开始，寻求一个编号最小的点且仍然可以抵达 $t$ 的点，然后走过去。这样循环走 $k$ 次就是答案。

一眼倍增。考虑我们提前预处理出每对 $(s,t)$ 从 $s$ 开始第 $1$ 步需要走向哪个点，很容易进行类似 LCA 的转移求出 $(s,t)$ 走 $2^i$ 步的位置。预处理出来之后求答案和转移类似，也是容易的。

特别地，转移的时候我们特判走不到或者走到 $t$ 的情况。已经走到 $t$ 之后的状态和走不到的状态都应该设置为不存在。如果求答案时用到了不存在的状态，就说明无解。

再考虑路径无限长怎么判断。可以发现，如果字典序最小的路径是有限长的，则一定不会两次经过同一个点（否则下一步也是相同的，就陷入环了），所以我们直接查询路径上是否存在走了 $n+1$ 个点的状态，如果存在就说明路径无限长。

这样就做完了。连通性不需要缩点和 topo，直接 dfs 就能做到 $\mathcal O(nm)$。总时间复杂度 $\mathcal O((n^2+q)\log n+nm)$。

#### T4

[JOISC2015 D2T2 备用钥匙](https://www.luogu.com.cn/problem/AT_joisc2015_f)

我们容易想到把时间轴画出来，然后发现每段时间能否关门只与时间段两侧事件的人是否有钥匙、进门还是出门有关。考虑这两个人分别是 $i,j$，不妨讨论一下所有的情况。

- $i$ 进门，$j$ 进门。$i$ 能关门当且仅当 $j$ 有钥匙。
- $i$ 进门，$j$ 出门。一定能关门。
- $i$ 出门，$j$ 进门。$i$ 能关门当且仅当 $i,j$ 都有钥匙。
- $i$ 出门，$j$ 出门。$i$ 能关门当且仅当 $i$ 有钥匙。

可以发现，我们的贡献形如某个人有钥匙就贡献，或者某两个人有钥匙就贡献。结合这个题浓重的 dp 味，我们可以自然想到，$i$ 有钥匙就贡献的部分，就直接垒到 $i$ 上，$i,j$ 有钥匙就贡献的部分，应该给 $i\to j$ 连边（很自然吧，按照时间顺序连边）之后放到边上。

类似那天研讨讲的 CF283C，我们发现这个图上每个点至多是一条入边一条出边，并且显然不可能存在环，所以就应该是一堆链了。我会 dp！

考虑显然的状态：$f_{i,j,0/1}$ 表示前 $i$ 个人有 $j$ 把钥匙，第 $i$ 个人有没有的最大贡献和。转移是比较显然的。

对于每条链跑出来这个之后背包一遍就可以了。写的时候需要精细实现一下，只需要对链长个物品做考虑，并且枚举状态只需要枚举到前面的链长和就足够了。可以发现这个 dp 实际上是形如子树合并，每一对不相同链中的点对都做贡献，时间复杂度是 $\mathcal O(n^2)$ 的。

总时间复杂度 $\mathcal O(n^2)$。

#### T5

[#3646. 「2021 集训队互测」《关于因为与去年互测zjk撞题而不得不改题这回事》](https://loj.ac/p/3646)

非常遗憾，目前 SA 简便精妙的 `multiset` 写法停滞在了 $15$ 秒的速度。但是没有人会常瑞年的抽象可持久化 Trie 操作和 gyh 的分块。

## 2024.10.16 树

树很复杂。

### 树本身

#### P6118 [JOI 2019 Final] 珍しい都市

> 题意：所有树点有一个颜色，计算距离某个点的距离独一无二的所有点中出现的颜色数量。要对所有点求解。

首先一个显然的结论，距离 $i$ 独一无二的点来自于一条链，并且这条链一定包含最远的点。如果有多个距离它最远的点，任意一条都是满足的。

那么不妨考虑把直径找出来。

考虑点 $i$ 距离最远的点一定来自于直径的一端。容易想到我们去统计某个端点对所有点的贡献，做两次就可以了。尤其注意到两边的答案具有覆盖性，也就是短一些的那一端答案总是 $0$，所以我们可以不区分哪个是真正的最远的端点（不合法不优），直接两端都做取 $\max$ 就可以了。

我们以一个端点为根，我们要对于每个点都快速统计出根到它的链上合法点的颜色数。考虑我们只要能维护所有这种点的添加删除就能类似莫队地实现数颜色。

不妨先长剖，这样每个点上深度最深的儿子成为重儿子。

考虑每个点上对到根的链产生最大影响的其实是重儿子。距离小于等于重儿子深度的点都会变成不合法的点，并且这种影响会延续到轻儿子中。也就是说，对轻儿子里的所有点，这些点也是不合法的，可以直接继承。

然后考虑重儿子，那就是距离小于等于最深轻儿子深度的点都会变成不合法的点了，重儿子里面的所有点也会继承这个。

此时你发现重儿子对不合法点的影响被轻儿子对不合法点的影响完全覆盖。所以说我们只要先做重儿子再做轻儿子，就可以很简单地维护合法点集，删掉的点不用再加回来了。

我们扫完之后就能计算这个点本身的贡献了。很容易证明子树中的点不会干涉到子树根的合法点，所以直接查就行了。

可以用一个 dfs 栈维护合法点集。考虑这个东西因为是按顺序的根到自己的一条链上的点集，应该是一个单调栈状物，从上至下距离越来越近，所以很容易维护，需要删点的的时候直接暴力弹栈就行了。

需要特别考虑一下这个点本身。这个点本身不受轻重儿子限制影响，所以需要特意加入，回溯的时候如果发现父亲在栈顶也要特意删掉。

每个点的进栈次数是度数次的，所以总时间复杂度 $\mathcal O(n)$。

很精妙的题。

[Code](https://loj.ac/s/2180181)

#### LOJ#6020. 「from CommonAnts」寻找 LCT

similar to [#6042.「雅礼集训 2017 Day7」跳蚤王国的宰相](https://loj.ac/p/6042)

一道乍一看没有什么思路的精妙题。为啥 LCA 这么强悍。

显然，自己连的边不会再删掉。所以删的都是原树边。

考虑操作的形态一定是，割掉一个子树把它直接接到根上，这是显然的。

考虑找出原树的重心，注意到任何一个大于一半的子树一定包含重心（如果不包含重心，那么它的大小一定小于等于重心在原来的任何一个子树，因为我们不会把两个子树接到一起）。

那么贪心地，我们要割肯定是割掉重心的前 $k$ 大子树，使得最后包含重心的连通块尽可能小。可以注意到割掉的子树一定不产生坏影响，因为它们的大小一定都小于等于一半。

不妨以重心为根，考虑重心的每个子树里的点。考虑现在重心上挂的所有子树（特别地，这个点所在的那个子树只保留排除该点子树的剩余部分，也就是连到重心的那部分），我们需要做的就是删除其中最大的 $k$ 个，查询其中剩下的部分的大小是否小于等于一半。

考虑怎么维护这个东西。为了直接干掉雅礼集训那个题，我们不妨直接计算至少要割掉多少条边才能使得它成为重心。直接拿权值线段树来维护每个子树的大小，每次在当前子树内的移动只会改变一个子树的大小，查询的时候在权值线段树上查询和的一半之前有多少个数就行了。

时间复杂度 $\mathcal O(n\log n)$。

[Code](https://loj.ac/s/2180341)，随便改改就能过雅礼集训那个题。

#### P5666 [CSP-S2019] 树的重心

~~咯噔题。~~ 简单题。

一个显然的转化，肯定是数每个点在多少种割边方案下成为某个子树的重心。

容易想到利用每个切出来的子树大小都要小于等于 $\left\lfloor\frac{n}{2}\right\rfloor$ 做换根。考虑到在设置重心为根之后这种子树不可能是这个节点的儿子子树，所以为了方便我们直接**设置重心为根**。（我没反应过来这个啊啊啊啊。）

如此一来，对于任何一个不是重心的点 $i$，导致这个点 $i$ 目前不是重心的问题就出在 $n-siz_i$ 部分（因为显然它的每子树内部是小于一半的），从而使它成为重心要割掉的边就一定是这个点子树外的边了（割里面的显然不会变优）。不妨假设以这个点为根，割掉的边所切割掉的子树大小为 $c$，于是需要满足：

$$
\begin{cases}
n-siz_i-c\le \left\lfloor\frac{n-c}{2}\right\rfloor\\
\max\limits_{j\in son_i}\{siz_j\}\le \left\lfloor\frac{n-c}{2}\right\rfloor
\end{cases}
$$

在这里因为所有数都是整数，所以下取整可以直接打开。从而：

$$
\begin{cases}
2(n-siz_i-c)\le n-c\\
2\max\limits_{j\in son_i}\{siz_j\}\le n-c
\end{cases}
$$

从而我们得到对 $c$ 的约束其实就是：

$$
n-2siz_i\le c\le n-2\max\limits_{j\in son_i}\{siz_j\}
$$

再加上 $c$ 必须在子树外，我们考虑用数据结构维护换根，并维护子树外的所有大小的子树有几个。直接刻画换根用权值线段树维护即可。

然后考虑重心如何能在切掉一个子树之后仍然还是重心。这并没有什么技术含量，我们直接枚举切掉哪个子树维护一下剩下的子树大小的 $\max$ 就行了，应该可以直接可删堆。比较优美的办法也可以讨论一下最大儿子子树和次大儿子子树，但我感觉都差不多。。

时间复杂度 $\mathcal O(n\log n)$。

### 研讨

by After_light

文字版题解：
1. https://www.luogu.com.cn/article/ajwwzc6g 
2. https://www.luogu.com.cn/article/kxo609b1
3. https://www.luogu.com.cn/article/2rt84led
4. https://www.luogu.com.cn/article/difp0s8f
5. https://www.luogu.com.cn/article/w9cpy9hf

注：这些题除了最短路那道基本上网上都可以搜到不少题解，所以可以自行选择更为优质的题解。

#### 一个神秘的题

waiting...

#### 约瑟夫环求出局者序列

考虑第一个出局的人是编号第 $k$ 小的，第二个人是编号第 $2k-1$ 小的，以此类推。线段树上二分即可。

#### ABC155F

首先显然差分，区间修改改成单点异或 $1$ 掉 $(l,r+1)$。我们不妨直接连出一张图。

然后我们容易发现这张图上的环都是没用的，所以抽一个生成森林就行了。

#### ABC138F

显然 $x,y$ 的最高位必须相同。

于是左边可以转成 $y-x$，考虑 $y-x=x\oplus y$，显然这说明 $y$ 必须是 $x$ 的超集。

然后显然是数位 dp……

考虑 dp 掉 $y$，设 $f_{i,b_1,b_2}$ 表示前 $i$ 高位，是否抵达 $L$ 的下界，是否抵达 $R$ 的上界的方案数。

#### LOJ#10202. 「一本通 6.2 练习 5」樱花

#### P9220「TAOI-1」椎名真昼

诈骗题。首先如果 A 操作了一个点，那么 B 就把它干回去就行了。换句话说，A 必须一步获胜，否则 A 赢不了。

考虑 B 怎么胜利。同理，B 必须在第二步一步获胜，否则 B 也赢不了。容易发现，需要：

- 白点不存在可达的黑点。
- 黑点不能不经过其他白点地到达两个白点。
- 不存在两个有黑点的连通块。

#### P2148 E&D

别打表你那 SG 函数了

#### P2490 [SDOI2011] 黑白棋

考虑每个白棋子和黑棋子中间的间隔，A 只能把白棋向右压缩，B 只能把黑棋向左压缩，当间隔为 $0$ 时这个间隔就报废了。

我们发现这很像取石子啊！有很多堆石子，每次只能拿 $[1,d]$ 堆石子中的一个，拿不了的人输。

当成拓展 Nim 游戏做。

#### P9133 [THUPC 2023 初赛] 大富翁

## 2024.10.17 树

### 研讨

#### 2024 牛客国庆集训派对 day1 E. Math

[link](https://ac.nowcoder.com/acm/contest/90188/E)

> 题意：给出 $n$，计数有多少对正整数 $(x,y)$ 满足 $xy+1|x^2+y^2$，其中 $1\le x,y\le n$。多组测试数据。

韦达跳跃（Vieta Jumping / Root Flipping），来自 [IMO 1988 Q6](https://zhuanlan.zhihu.com/p/188465634)。

我们沿用 Emanouil Atanassov 的证法：

考虑 $x=y$ 的解有且仅有 $(1,1)$。

> Proof.  
> $x=y\Rightarrow (x,y)\ \text{satisfy}\ x^2+1|2x^2$，考虑把 $x^2$ 项拆出来，剩下 $x^2+1|2$，显然只存在 $x=1$ 一个正整数解。

不妨令 $x<y$。设 $k=\frac{x^2+y^2}{xy+1}$，那么移项有：$x^2+y^2-kxy-k=0$，不妨设 $x$ 为方程的主元，那么根据韦达定理我们有另一个解 $x'$ 满足：

$$
\begin{cases}
x+x'=ky\\
xx'=y^2-k
\end{cases}
$$

我们沿用 IMO 1988 Q6 的结论，$k\gets t^2$。于是：

$$
\begin{cases}
x+x'=t^2y\\
xx'=y^2-t^2
\end{cases}
$$

反解 $x'=t^2y-x$。对于所有 $t^2>1$，我们可以直接移项证明 $t^2y-x>y$。换句话说，另一个解 $x'$ 事实上提供了下一对解 $(y,x')$，从而可以继续产生解。

对于 $t^2=1\Rightarrow k=1$，我们考虑 $xy+1=x^2+y^2$。利用均值不等式我们知道 $x^2+y^2\ge 2xy$，所以 $xy+1\ge 2xy\Rightarrow xy\le 1$，考虑到 $x,y$ 都是正整数所以 $xy\ge 1$，所以 $xy=1\Rightarrow x=y=1$，这是我们已经排除掉的情况。

我们首先证明对于相同的 $k=t^2$，所有解都仅由一组解通过韦达跳跃取得。

> Proof.  
> 我们不妨假设存在一组解 $(x_0,y_0)$，它不由韦达跳跃取得。再假设一组解 $(x_1,y_1)$ 由韦达跳跃取得，则它们同时满足一个二元二次方程。  
> 然后我就不会证了。

我们发现，对于 $k=t^2$，它 $x$ 最小的一对解是 $(t,t^3)$。

> Proof.  
> 考虑利用上一个结论，那么这个解一定是韦达跳跃得到的。换句话说，存在一组解 $(x_0,t)$。回代之后发现 $x_0=0$ 或 $t^3$，因此不存在更小的解。

于是我们考虑从 $(t,t^3)$ 开始进行韦达跳跃求出 $y\le n$ 的解数。

注意到第一步之后得到的解是 $(t^3,t^5-t)$。所以范围内存在两个解的 $t$ 最多只有 $3981$。但是暴力做到 $3981$ 过不了。

我们发现第二步得到的解是 $(t^5-t,t^7-t^3-t)$。精细计算一下，范围内存在三个解的 $t$ 只有 $372$。因为每次是指数增加的，所以直接暴力计算到 $372$ 就够了。然后单独计算一下跳跃两步和跳跃一步的答案。

这样就可以压线 917ms 通过。

#### Code

```cpp=
int tc;
ll n;
ll ans;
ll pow5(ll x){
    return x*x*x*x*x;
}
void solve(){
    ans=0;
    cin>>n;
    fr1(i,2,372){
        __int128 k=i;
        __int128 x=k,y=k*k*k;
        int s=0;
        while(y<=n){
            s++;
            __int128 t=y;
            y=k*k*y-x;
            x=t;
        }
        ans+=max(0,s-2);
    }
    int l=1,r=3981;
    ll pans=0;
    while(l<=r){
        ll mid=(l+r>>1);
        if(pow5(mid)-mid<=n) pans=mid,l=mid+1;
        else r=mid-1;
    }
    ans+=pans-1;
    l=1,r=1000000,pans=0;
    while(l<=r){
        ll mid=(l+r>>1);
        if(mid*mid*mid<=n) pans=mid,l=mid+1;
        else r=mid-1;
    }
    ans+=pans-1;
    cout<<ans+1<<'\n';
}
```

## 2024.10.18 模拟赛

### T3

P10794

不妨逐步考虑。

- 不做操作。答案是树的直径。
- 只进行一次操作。我们肯定是要选新建的这条边的，否则此次操作没有意义。你发现这个操作等价于任选一条从叶子出发的、不经过根节点的路径，删除路径上深度最小的点的父亲边，然后将其挂在根节点的下方。那么我们需要选择另一条从根节点出发的路径拼成答案。注意两条路径不能相交，否则找不到合法的可以删除的边。
- 进行两次操作。进一步推广，这等价于你选择了两条不交的、且不经过根节点的路径，分别挂在根节点下方，答案显然为选择的两条路径长度之和 $+2$。

进一步地，你发现进行 $3$ 次及以上的操作是没有意义的，因为不可能存在一条路径同时覆盖了三条新增的边。同时，不做操作和只做一次操作的情况下，也可以认为是选择了两条不交、且不经过根节点的路径。因此原问题得到转化。

对于这个新问题，考虑树形 dp 解决。设 $dp_i,f_i,g_i,h_i$ 分别表示在以 $i$ 为根的子树中划分出 $1$ 条以 $i$ 为端点的链的最大链长、划分出 $2$ 条链，其中一条以 $i$ 为端点的最大链长和、划分 $1$ 条端点任意的链的最大链长、以及划分 $2$ 条端点任意的链的最大链长和。利用这四个数组进行转移是容易的。

注意由于链不能经过根节点，需要对根的每个子树分别讨论并计算答案。最后记得加上新建的两条边的贡献。复杂度不难做到 $O(n)$。

### T4

AGC003F

考虑连通块的数量会怎么变化。分情况讨论：

1. 原图所有黑色点形成一个连通块，即竖直、水平均连通。那么无论这个网格怎么分形，它都将会是一个连通块。答案为 $1$。
2. 原图所有黑色点都不相邻，即竖直、水平均不连通。那么网格每分形一次，连通块数量就会变成 $cnt^{k-1}$ 个。$cnt$ 为原图中黑点的数量，$k$ 为当前分形是第几个。
3. 原图黑点部分相邻。此时需要单独计算。

这里水平连通指存在 $i(1\le i \le n)$，使得 $a_{i,1}=1\land a_{i,m}=1$。其中 $1$ 表示黑色点。竖直连通同理。

考虑计算第 $3$ 种情况的答案。不难发现，此时仅存在水平连通或竖直连通 $2$ 种情况。它们本质上是相同的，这里仅考虑水平连通的情况。记 $c_1$ 为当前分形中黑点数量，$c_2$ 为当前分形中相邻的黑点对数。即 $a_{i,j}=1\land a_{i,j+1}=1(1 \le i \le n\land 1 \le j <m)$ 的 $(i,j)$ 数量。会发现，当当前分形继续分形一次后，会增加 $c_1-c_2$ 个连通块。那么就好做了，定义状态函数 $f_i$ 表示第 $i$ 次分形的连通块数量。记 $x$ 为原图中黑点数量，$y$ 为原图中相邻黑点对数，$z$ 为 $a_{i,1}=1\land a_{i,m}=1(1\le i \le n)$ 的数量。那么有：

$$
f_{i}=f_{i-1}\times x -y\times z^{i-1}
$$

发现 $k$ 的值域很大。但是递推的方式相同，我们把 $z^{i-1}$ 也当作状态方程放进去转移，记作 $g$。那么就有：

$$
\begin{bmatrix}f_{i-1} &g_{i-1} \end{bmatrix} \times \begin{bmatrix} x & 0\\ -y & z \end{bmatrix}=\begin{bmatrix}f_{i} &g_{i} \end{bmatrix}
$$ 

直接矩阵快速幂优化能够做到 $O(nm+\log k)$ 的时间复杂度。

### 研讨

#### [ARC104D]

唐诗。考虑枚举 $x$，再将所有值减去 $x$。那么现在就相当于在 $1-x \sim n-x$ 中选一些数，使得和为 $0$。再将其分成 $1-x \sim -1,0,1\sim n-x$ 三个部分。将第一部分取反之后能够预处理出来方案数了。时间复杂度 $O(n^3 k)$。

#### [JOISC2016 H]

注意到不正常的时限。考虑分块做法。

对于一个区间 $[l,r]$ 与当前的 $x$。$x$ 遍历完这个区间之后一定会成为 $\max(\max\limits_{i=l}^{r}a_i,x)$。看出这个不难。那么，我们对于每个块动态维护其最大值，就能得到 $x$ 最终的值了。

现在考虑修改。记 $j$ 为区间 $[l_i,r_i]$ 中第一个比 $x$ 大的位置。那么 $[j,r_i]$ 一定程不降的形式，因为一但有一个 $a_k >a_{k+1}$，我们都会通过 $x$ 将其排好。那么对于 $[l_r,j)$ 中的值，能够保证 $\forall k\in[l_i,j),a_k<a_j$。因为 $a_k\le x\land a_j >x$。于是就好做了，我们能够通过维护前缀最小值得到 $a_i$ 的值。形式化地，对于每次将最大值与 $x$ 比较时，先将 $x$ 加入队列。对于每个 $i$，将 $a_i$ 加入队列。然后每次 $a_i$ 的实际值为当前最小的值。

证明简单。如果 $x$ 存在 $x<a_j$ 的情况，那么 $Max$ 将会被顶出来。如果不存在，那么 $x$ 将会成为最后一个（这里的最后一个不一定是队列的最后一个，因为可能存在多个这样的 $x$）。

动态维护最大和最小值，使用优先队列即可。时间复杂度 $O(q\sqrt{n}\log n)$。$9$ 秒足够了。

#### CF643F

## 2024.10.20讲课记录

### 树上问题

#### dfn 序

#### 欧拉序

$dfs$ 整树形成的序列

求 $lca$ ：$x$ 和 $y$ 中间 $deepth$ 最小的点

求距离：$x$ 第二次出现和 $y$ 第一次出现的中间的点的数量，减去那些出现了 $2$ 次的点对数（当成括号序列匹配之后的长度）

例题：给一棵有根树，支持加叶子，支持查询一个子树当前的直径

放在欧拉序上，由于距离是 XXX ，我们可以把直径问题转化成对于一个括号序列找到最大子段和，把加叶子转化成加一对括号

$a$ 为前缀连续右括号的数量，$b$ 为中间左括号的数量，$c$ 为中间右括号的数量， $d$ 为后缀左括号的数量，区间的贡献为 $a+b+c+d-min(2c, 2d)$ 

#### Prüfer 序列

计算 $n$ 个点的无根树的数量

把一颗无根有标号的数，每次把所有叶子里面编号最大的删掉，可以唯一表示这颗树，删 $n-2$ 次，最后剩下 $2$ 个点。同样的，我们可以根据序列来生成一棵树

例题：存在一个完全二分图，左边有 $n$ 个点，右边有 $m$ 个点，问生成树数量。

首先删到最后一定剩下一个左部点和一个右部点，剩下有 $n-1$ 个左部点和 $m-1$ 个右部点，我们发现剩下的点方案数为 $n^{n-1}*m^{m-1}$ 

例题：P11039

问题相当于给了你一个树，你对他进行拓展，有多少种方案。

要么是给一个边上加点，要么是往点上挂叶子，要么是往根的上方加父亲。

边加点方案数只跟边数有关，挂叶子只跟点数有关。

换而言之，前两种方案数的变化只跟树的大小有关。

求出虚树大小 $m$，那么枚举 $i$ 个点插入在虚树的边中，剩余的 $n−m−i$ 个点可以看成一些散点，要和一个大小为 $m+i$ 的块连成树，可以用 Prüfer 序列直接算答案

那么相当于将新的根变成虚树根的父亲，即 $m←m+1$ 后重算答案即可。

例题：uoj176

首先，全局最大边权是简单的，可以使用 $trie$ 树状物计算。

但是无法直接记下来所有可能出现在生成树中的边，数量太多。

我需要维护一个数集，支持查询一个二进制数与某个数按位与的最大值

提供一种新做法：

因为边权很小，所以可以枚举边权，考虑这条边有没有贡献。

可以考虑如果两个点点权相同，那么它们连起来，一定是最优的。

这样我们就可以直接加上相同点的贡献，然后留下互不相同的点，以他们的点权为编号。

对于 $i$ 的边权，我们可以枚举所有 $x \& y=i$ ，如果存在 $x,y$ 且 $father[x]≠father[y]$ 那么就贪心连起来。

但是枚举x,y实在是做不到，因此我们可以将 $x$ 传递到 $x$ 的子集中，这样子就只需枚举 $i^2|j$ 了。

例题：loj6631

没听懂 lca 在说啥，于是[看题解](https://www.watertomato.com/loj6631-%e3%80%8cec-final-2018%e3%80%8d%e5%bc%82%e5%9b%bd%e6%83%85%e8%b0%83%e7%9a%84%e5%8f%a4%e5%9f%8e-exotic-ancient-city/)

## 2024.10.22 咋又讲构造

### LOJ #538.「LibreOJ NOIP Round #1」数列递推

考虑若 $a_0,a_1\ge 0$ 或者 $a_0,a_1\le 0$，那么整个东西是单调的，答案在最大和最小的 $s_i$ 中产生。

进一步地，考虑 $a_0,a_1$ 不同号怎么办。考虑这个东西类似辗转相除法，总有一边会变成自己减对面，所以应该 $\log$ 次之后就会有一个东西影响变成 $0$。

所以暴力 $\log$ 位，剩下的矩阵就行。

### 带模数的斐波那契循环节

循环节的长度是 $\mathcal O(p)$ 的。

### QOJ5528. Least Annoying Constructive Problem

SJY 在 APIO 讲过的题。大概就是把 $n$ 个点排在圆上，我们第一个 $n-1$ 条边从一个点开始向下、向上沿着两边依次进行三角剖分，第二个 $n-1$ 条边就将这个三角剖分沿着第一步的反方向挪动一个点同样操作就可以了。

### CF468A