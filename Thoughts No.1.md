Developed by Shunpower, StayAlone, Zelotz, H_Z_J, LPhang, WaterSun, harmis_yz

[Github - Shunpower - Qingdao Thoughts Repository](https://github.com/Shunpower/Qingdao-Thoughts/)

## 思考题

### 思考题 1：介值定理
有 $n$ 个物品，每个物品有重量 $w_i$ 和体积 $v_i$ 且密度均匀。你可以切物品，每次可以选一个物品切成两部分，也就是选一个 $0$ 到 $1$ 的实数 $k$ 把物品分成 $k$ 和 $(1-k)$ 比例的两个物品。

你有最多 $X$ 次切的机会。

1. 要想保证切完之后一定能把物品分成两组使得两组重量和相等，体积和也相等，$X$ 至少是几。
2. 设计高效算法求问题 1 的方案。
3. 如果是分成三组呢？
4. （问题 0）如果是要把物品分成两组使得两组数量相同且体积和也相等呢（不考虑重量）？

### Solution

介值定理：若函数 $f(x)$ 是一个连续函数，满足 $l\leq r$ 和 $val \in [f(l), f(r)]$ ，一定能取到至少一个 $x$ 满足 $f(x)=val$ 。

#### 问题 1

首先，我们可以举出反例，证明只切一次是不行的：
$$
\begin{matrix}
v = \{1,10\}\\
w = \{10,1\}
\end{matrix}
$$
在这种情况下， $v_2 > \frac{\sum v} 2$ ， $w_1 > \frac{\sum w} 2$ ，至少也得切两次。

我们考虑将所有物品按照等单位的体积 $v_i$ 排成一环，考虑一条直径把整个环分成左右两个区域，此时左右区域的体积一定相等。

我们设左右区域的重量分别为 $x$ 和 $y$ 。

以这条直径为法线，以圆心为轴心，我们增大夹角 $\theta$ ，旋转直径，会将整个环分成两个部分，最后 $x$ 和 $y$ 的值将会互换。
根据介值定理， $x$ 和 $y$ 是连续变化的，因此在变化的过程中， $x=y$ 的时刻一定会出现。由此得证，切两次的一定可以。

#### 问题 2

[TBA]

### 思考题 2：平衡 / 树分治

对一个序列 $a_1\cdots a_n$，找一个位置 $x$，使得 $a_1+\cdots+a_x$ 和 $a_{x+1}+\cdots+a_n$ 的比值在 $[\frac{1}{c},c]$ 之间，要求 $c$ 尽可能小。
 
1. $c$ 最大情况下是多少，并构造对应 $c$ 的例子。
2. 如果允许将某一个 $a_i$ 原位切开成两个相邻的位置，这两个位置的权值均为整数且加起来是 $a_i$ 且任意分配，$c$ 最大情况下是多少，当 $n$ 很大并且 $a_i\ge 1$ 的情况下，$c$ 会变小吗？

对一棵 $n$ 个点的树，找一条边，使得这条边断开后，两边的连通子图的点数比值在 $[\frac{1}{c},c]$ 之间，要求 $c$ 尽可能小。
 
3. $c$ 最大情况下是多少，并构造对应 $c$ 的例子。
4. 如果树是一棵二叉树，对任意一个给定的 $n$，$c$ 最大情况下是多少，并给出一个通用的构造对应 $c$ 的例子的算法。
 
在树的基础上，如果给定一个结点 $x$，将 $x$ 删去后剩下若干个连通子图，将这些连通子图分成两组，使得两组点数的比值在 $[\frac{1}{c},c]$ 之间，要求 $c$ 尽可能小。
 
5. $c$ 最大情况下是多少，并构造对应 $c$ 的例子。
6. 如果结点 $x$ 是你自己选定的，$c$ 最大情况下是多少，并构造一个通用算法。

### Solution

#### 问题 1

考虑到没有提供值域范围，所以设置 $a_1=+\infty$ 即可使得 $c=+\infty$。

#### 问题 2

定义 $sum=\sum a_i$。

简单题，但是**不能使用介值定理。**

考虑由于切分只能切分成两个整数，所以表示两边比值的函数 $f(x)$ 并不是连续的。

但是我们可以先考虑连续情况下的问题。切分连续情况下，我们必然可以将其在 $\frac{sum}{2}$ 处切分为两半，从而对于任意序列答案均为下界 $1$。其中，若 $sum$ 为偶数，则不会发生切分或被切分的 $a_i$ 将产生两个整数；反之若为奇数，被切分的 $a_i$ 将产生 $\frac{1}{2}$ 大小的零碎部分。

现在我们考虑切分不连续。首先对于 $sum$ 为偶数，下界 $1$ 仍然可以取到。而对于奇数，我们容易证明仍然在 $l=\left\lfloor\frac{sum}{2}\right\rfloor$ 或 $r=\left\lceil\frac{sum}{2}\right\rceil$ 处切分最优，因为这两处相邻点的答案显然相等，而将 $l$ 向左调整或将 $r$ 向右调整答案均不优。

#### 问题 3

最坏情况下我们希望无论怎么切两个连通子图都其中一边是一个叶子，剩下的部分是除了这个叶子的整棵树，所以菊花图非常合适。对于菊花图，$c=n-1$ 且显然是答案的上界。

这就是卡直接应用边分治的方法。边分治希望删掉一条边使得两个连通子图的大小尽量接近，然而菊花图上直接应用边分治的复杂度是错的。

#### 问题 4

答案是 $2$。这个值是容易构造证明可取的：我们构造一个每条链等长的三叶草即可。

我们考虑证明这是上界。也就是说，我们只需要证明不存在一种树的形态使得找到最小的边比 $2$ 大。

考虑序列与二叉树性质的不同点：序列上的每个点都是至多二度的，而二叉树上每个点都是至多三度的。

考虑二叉树上的二度点 $v$：$u_1\leftrightarrow v\leftrightarrow u_2$。对于这种情况，类似序列，我们总是可以通过调整使得答案减小（总是可以让一个连通子图少一个点，另一个多一个点，让多的那个少即可），让答案趋近于下界 $1$。

我们考虑三度点 $v$（连向 $u_1,u_2,u_3$）。假设在某条边上答案 $>2$，那么说明目前有两个连通子图的节点数量和（假设是 $siz_{u_1}$ 和 $siz_{u_2}$）超过另一个连通子图的两倍（假设是 $siz_{u_3}$）。那么考虑：

$$
\begin{aligned}
&2siz_{u_3}<siz_{u_1}+siz_{u_2}\\
\iff& siz_{u_3}<\frac{siz_{u_1}+siz_{u_2}}{2}\\
\iff& siz_{u_3}<\max(siz_{u_1},siz_{u_2})
\end{aligned}
$$

我们考虑捆绑 $siz_{u_3}$ 和 $\min(siz_{u_1},siz_{u_2})$，显然 $siz_{u_3}+\min(siz_{u_1},siz_{u_2})<\max(siz_{u_1},siz_{u_2})$，所以答案就一定会变小。综上，答案不可能 $>2$。

这就是边分治[三度化](https://oi-wiki.org/graph/tree-divide/#%E8%BE%B9%E5%88%86%E6%B2%BB)的原理。边分治通过把多叉树用三度化转换成二叉树保证只要边找得好每次切分就肯定可以把树规模缩小一半，从而保证复杂度正确。

#### 问题 5

答案是 $+\infty$。我们考虑搞一个很大的子树和一个叶子，二叉地接在 $x$ 上，即可构造得到。

#### 问题 6

答案也是 $2$。

我们对多叉树应用常规的三度化（搞一条虚点链，每个虚点上一个叉接一个实点儿子子树，另一个叉往下接），这样我们的一个分组就转化为选择一条边断开（要么是实点虚点边要么是虚点虚点边），且整个树转成了一个二叉树，从而等价于问题 4。由于对于任意实点儿子子树在虚点链上的排列方式答案都只能做到 $2$，从而对于任意分组方式答案都只能做到 $2$。

我们考虑用这个证明直接对任意树应用点分治总可以做到复杂度正确。考虑我们找到一个很好的点做根，满足可以把它的子树分成 $1:2$ 的两半，那么每一半又可以继续划分（具体的，建立一个虚点把那些子树合起来就能规约回来），从而每个儿子子树几乎均分整个子树。显然这种点不可能只有一个子树（对于 $n$ 足够大），所以每次子树大小至少折半，从而点分治复杂度正确。

### 思考题 3：旋转扫描线

二维平面上有 $n$ 个点，要求这些点互相不重合，并且三点不共线，编号为 $[1,n]$，现在我们要画一条直线，如果一个点 $(x,y)$ 满足 $Ax+By+C\ge0$，则视为点 $(x,y)$ 在直线 $Ax+By+C=0$ 的上方。将直线上方的点看做是一个集合。

1. 如果 $n$ 个点的坐标由你来构造，对直线 $Ax+By+C=0$，假设 $A,B,C$ 取遍所有实数，最多可以得到多少个不同的集合。
2. 如果有若干条直线，其上方点的集合相同，是否可以通过对这些直线进行旋转和平移，使得这些直线变成同一条直线。
3. 如果改变你在问题 1 中构造的点的坐标，不同的集合数是否会发生改变。
4. 给定点 $(x,y)$，对于所有过 $(x,y)$ 的直线，是否一定存在一条直线，使得直线两侧的点数最多只差 $1$，这里的点数不统计 $(x,y)$，如果点在直线上，由你决定属于哪一侧。
5. 是否可以找到两条相交的直线，使得给定的 $n$ 个点被分成四个点集，且最大的点集和最小的点集大小最多差 $1$，如果点在直线上，由你决定属于哪一个点集。
6. 是否可以找到三条共点的直线，使得给定的 $n$ 个点被分成六个点集，且最大的点集和最小的点集大小最多差 $1$，如果点在直线上，由你决定属于哪一个点集。

### Solution

[TBA]

### 思考题 4：区间最大子段和

区间最大子段和问题：给定一个长为 $n$ 的整数列 $\{a_i\}$（有正有负），每次查询一个区间，问这个区间的所有子区间中，区间和最大的是多少。

1. 如果有一种修改是全局加同一个数，且只有全局查询，如何维护。（考虑，所有可能的答案区间有哪些？）
2. 如果有一种修改是全局加同一个数，且所有询问区间都是后缀（右端点都是 $n$），如何维护。
3. 给定一个长为 $n$ 的整数列 $\{a_i\}$（有正有负），求出每个后缀的平均值最小的前缀。【ABC341G】
4. 给定一个长为 $n$ 的整数列 $\{a_i\}$（有正有负），区间加，区间查询平均值最小且长度不小于 $k(k\le 10)$ 的子区间。
问题5. 区间加正数，区间最大子段和。（考虑能否用组合方法证明复杂度？）【P5693】

### Solution

[TBA]

### 思考题 5：下标值域迭代

有一个 $n$ 阶排列 ${a_i}$，定义 $f([l,r])=[\min(a_l,\dots ,a_r), \max(a_l, \dots, a_r)]$。

0. 对一个初始区间不断迭代 $[l,r], f([l,r]), f(f([l,r])),\dots$，如何刻画这个过程。
1. 对输入的 $[l,r]$，设计一个尽可能高效的算法判定多次迭代 $f$ 能否达到 $[1,n]$
2. 对输入的 $[l,r]$，如果可以迭代达到 $[1,n]$，设计算法求出最少需要迭代 $f$ 多少次。（CF1707E）
3. 对任意一个 $[l,r]$，不断迭代 $f$ 可达到的不同区间个数的（渐进）上界是多少？（也是上个问题答案的上界）
4. 如果给定的 $a$ 不是排列，而是一个值域 $1$ 到 $n$ 的数组，数值可以重复出现，问题3的答案会有变化吗？（CF1707E）
5. 如果多次区间询问有多少个子区间可以在有限步内迭代到 $[1,n]$，能做吗？
6. 如果多次区间询问有多少个子区间可以在有限步内迭代回到自身，能做吗？

### Solution

#### 问题 0

定义一个极大的区间 $[l,r]$ 满足 $f([l,r])=[l,r]$。不难发现极大的一个区间满足区间 $[l,r]$ 的值域在 $[l,r]$，除了长度为 $1$ 的区间相当于在置换环上一直跳，一个非极大的区间，经过不断的迭代一定可以到达一个极大的区间，然后停止改变。

#### 问题 1

显然两个极大的区间拼在一起的时候也构成极大的区间，故 $[1,n]$ 显然为极大的区间。一个区间 $[l,r]$ 可以迭代到 $[1,n]$ 说明没有比 $[1,n]$ 更小的极大的区间包含 $[l,r]$，所以不难发现端点 $l$ 处于最左边的极大的区间中，端点 $r$ 处于最右边的极大的区间中，$\mathcal{O}(n)$ 处理极大的区间并判断即可。

#### 问题 2

对于任意区间，因为是排列，所以值域差大于等于区间长度，而对于一个极大的区间，每个真子区间的值域差一定大于区间长度，因此每次迭代都会使区间长度变大，最多迭代 $n$ 次，使用 $\text{ST}$ 表模拟即可计算。当然，对于长度为 $1$ 的区间因为是跳置换环，所以也不超过 $n$ 次。

#### 问题 3

由上一问，显然为包含区间 $[l,r]$ 的最小的极大区间的长度。



[TBA]

### 思考题 6：$\pm1$ 前缀和 / 众数

给你一个由 $+1$ 和 $-1$ 构成的序列，其中 $+1$ 的个数只有 $x$ 个，$-1$ 的个数有 $n-x$ 个。$x$ 默认远小于 $n$。

1. 最多有多少个前缀，满足前缀和 $\ge 0$？满足前缀和 $\ge0$ 的前缀最多的情况下，有多少种不同的序列？
2. 如果要求所有的前缀和都 $\ge0$，有多少种不同的序列？
3. 最多有多少个区间，满足区间和 $\ge0$？并给出对应的构造。
4. 对于序列中的一个位置 $i$，假设对任意包含 $i$ 的区间 $[l,r]$，该区间的和都 $<0$，这样的 $i$ 需要满足什么条件？

在原问题的基础上，定义一个序列的价值为：找出所有满足区间和 $>0$ 的区间 $[l_i,r_i]$，对这些区间求并。

5. 对所有可能的序列，最大的价值是多少？
6. 对于一个给定的序列，输入格式为所有 $+1$ 的位置，如何在 $\mathcal O(x\log n)$ 时间复杂度内求出该序列的价值？这里需要考虑 $x$ 远小于 $n$。

接下来回到原问题。

7. 对于一个给定的序列，假设 $x$ 最大和 $n$ 同阶，我们想求出有多少区间的和 $\ge0$，是否存在 $\mathcal O(n)$ 的算法？请给出一个 $\mathcal O(n)$ 的算法，或者尝试归约一个已知 $\mathcal O(n)$ 困难的问题。【P3770】
8. 如果问题 6 存在 $\mathcal O(n)$ 的算法，那么对于一个给定的序列，假设 $x$ 远小于 $n$，输入格式为所有 $+1$ 的位置，我们想求出有多少区间的和 $\ge0$，是否存在 $\mathcal O(x)$ 的算法？
9. 可以用这个方法尝试 $\mathcal O(n\log n)$ 解决 P4062，CF1446D2。

### Solution

[TBA]

### 思考题 7：区间排序

有一个长为 $n$ 的数列 $a[1\dots n]$。

有一种排序过程，每一步操作为 $s(l,r)$ 表示对数列当前的 $a[l\dots r]$ 排序。（相当于 C++ 调用 `sort(a+l,a+r+1)`）

如果一个排序过程对于任意可能的 $a$ 的取值都能排序，就称这个排序过程是合法的。

1. 给定常数 $x,y,n$，只使用 $s(1,x)$ 和 $s(y,n)$ 构造一个合法排序过程至少需要几步。
2. $a$ 的值域和排序合法性有关吗？如果我们限制 $a[1\dots n]$ 是一个排列，或者限制 $a$ 的每个元素取值都在 $[0,K]$（$K$ 是正整数）内，是否存在一个排序过程对于这两种限制的合法性不同？
3. 如果操作区间长度不能超过 $2$ 也就是对相邻两个数排序，一个合法排序过程至少需要几步？
4. 如果操作区间长度不能超过 $3$，一个合法排序过程至少需要几步？
5. 哪些我们常见的排序算法可以写成这样的静态排序过程（不允许根据输入调整操作顺序）？哪些我们常见的排序算法可以写成这样的排序过程（允许根据输入调整操作顺序）？

### Solution

#### 问题 1

对于 $x\ge y$，答案是 $2\left\lceil\frac{\min\limits(x,n-y+1)}{x-y+1}\right\rceil$。对于 $x<y$，无解。

> 证明 by Ph & Sp：\
> 对于 $x<y$，构造 $x$ 个最大的数放在 $x$ 前缀，构造 $y$ 个最小的数放在 $y$ 后缀，则该序列永远无法使用这种方式排好序，因为两段不相交。\
> 对于 $x\ge y$，继承证明无解的想法。\
> 首先最优解显然必须是两种操作轮流。不妨令 $x\le n-y+1$ 也就是前面的数总是更少。我们每轮可以用一次 $s(1,x)$ 操作把 $x-y+1$ 个数从前面中转到相交处，然后用一次 $(y,n)$ 操作从相交处移动到后面，并从后面带来需要移动到前面的数。那么我们最多需要操作 $2\left\lceil\frac{x}{x-y+1}\right\rceil$ 次使得前面的每一段 $x-y+1$ 个数都挪动到相交处再挪到后面去。\
> 提供一个卡满的构造：$x=3,y=2,n=9,\{a_n\}=\{9,8,7,6,5,4,3,2,1\}$，这必须进行至少 $4$ 次。

#### 问题 2

都不存在。

#### 问题 3

逆序对数量。

> 证明：\
> 考虑任意未完成排序序列 $a$ 中交换两个位置，至多减少一个逆序对（且显然存在至少一个逆序对），所以最有效的办法也必须交换逆序对数量次。\
> 使用冒泡排序即可构造性达到该下界。

考虑反排列，存在 $\frac{n(n-1)}{2}$ 个逆序对，所以这就是答案，使用朴素冒泡即可构造达到。

#### 问题 4

[TBA]

#### 问题 5

不允许：

插入排序：$[n,n],[n-1,n],[n-2,n]\cdots [1,n]$。

冒泡排序：$[1,2],[2,3],[3,4]\cdots [n-1,n]$ 重复 $n-1$ 次。

归并排序：线段树区间从下至上，`pushup` 时进行 $s(l,r)$ 合并。

允许：

[TBA]



### 思考题 8：AGC001F

给定一个排列 $p$，你可以任意交换相邻两个绝对值差 $\ge K (K\ge 1)$ 的数，问能得到的序列中字典序最小的。

1. 如果我们按任意顺序，只交换相邻逆序对（也就是 $a_i\ge a_{i+1}+K$ 的情况），如果不存在可以交换的绝对值差足够大的相邻逆序对就结束。我们可以得到的最终序列是唯一的吗？
2. 找出一个较为简洁的，判断一个序列能否被得到的充要条件。

类似排序，在这个问题中我们定义 $s'(x,y)$ 表示对排列当前的 $p[l\dots r]$ 区间调整成区间内字典序最小的。如果一个排序过程对于任意可能的 $p$ 的取值都能得到所有能得到的序列中字典序最小的，就称这个排序过程是合法的。

3. 冒泡排序合法吗？
4. 思考题 7 问题 5 中其它的排序合法吗？比如归并排序？
5. 在以上两问的基础上设计高效算法解决原问题。【AGC001F】
6. 有些在此题中的合法排序过程未必是一般排序的合法排序过程，例如当 $K=\infty$ 的时候每个序列的答案就是本身，任何排序过程都合法。那么反过来，是否存在一个对于一般排序（也就是 $K=1$）的合法排序过程，在 $K$ 取较大值的情况下不合法？

### Solution

#### 问题 1 

唯一。

> 证明 by LCA：\
> 不妨假设存在两个最终的排列 $a,b$，考虑前缀第一个不同的位置 $i(i<n)$。不妨设 $a_i<b_i$。\
> 考虑 $b$ 中一定有个 $i$ 之后的位置存在 $a_i$，所以 $a$ 排列换为 $b$ 排列一定至少是将 $a_i$ 向右移动得到的。从而 $b_i$ 到 $b$ 中 $a_i$ 间一定有一个时刻有大量 $\le a_{i}-K$ 的数，而这些数显然也 $\le b_i-K$。由于每次交换只会把数越换越小，所以 $b_{i+1}$ 必然 $\le b_i-K$，所以 $b$ 不可能是一个不可继续换的排列。

#### 问题 2 

差 $d \in [0, k-1]$ 的数字相对顺序不变。

#### 问题 3 

冒泡排序：可以

#### 问题 4 

归并排序：可以

#### 问题 5

这不归并，复杂度 $O(N\log N)$

#### 问题 6 

[TBA]

### 思考题 9：自动机

补充自动机定义为输入一个序列，从左往右读入字符，每读入一个字符需要决定输出一个字符（可以不输出）。

1. 给定一个长度为 $n$ 的加法算式，求这两个数字的和，这个问题是否可以用一个状态数 $O(1)$ 的自动机解决？如果可以，请构造出该自动机。\
输入样例：`114514+1919810=`\
输出样例：`2034324`
2. 给定两个长度为 $n$ 的数字，求这两个数字的和，如果将两个数字分别从最高位开始交替输入，这个问题是否可以用一个状态数 $O(1)$ 的自动机解决？如果可以，请构造出该自动机。\
输入样例：`12345678`，表示将 $1357$ 和 $2468$ 这两个数字求和\
输出样例：`3825`
3. 给定两个长度为 $n$ 的数字，求这两个数字的和，如果将两个数字分别从最低位开始交替输入，这个问题是否可以用一个状态数 $O(1)$ 的自动机解决？如果可以，请构造出该自动机。\
输入样例：`87654321`，表示将 $1357$ 和 $2468$ 这两个数字求和\
输出样例：`3825`
4. 给定一个长度为 $n$ 的序列，每个位置的值是整数，且在 $[-n,n]$ 之间，求这个序列的最大子段和，这个问题需要用状态数为多少的自动机解决？请给出对应最小状态数的构造。\
输入样例：`1 -2 3 -4 -5`\
输出样例：`2`
5. 给定一个长度为 $n$ 的序列 $a$，每个位置的值是整数，且在 $[-n,n]$ 之间，求最大的 $a_i+a_j+a_k$ 满足 $i<j<k$，这个问题需要用状态数为多少的自动机解决？请给出对应最小状态数的构造。\
输入样例：`1 -2 3 -4 5`\
输出样例：`9`

## 2024.9.29 排序问题

### Q1. 排序网络

> Statement：\
> 给你 $m$ 个数对。对于一个排列 $p_n$，每个 $(x,y)$ 表示一个操作：
> - 若 $p_x>p_y$，交换 $p_x,p_y$。
> - 反之，无事发生。
> 
> 你需要判断这 $m$ 个数对是否可以将任意排列都排序。$1\le n\le 20,1\le m\le n^2$。

考虑任意一个排列可以被排好的一个充分必要条件：

> 枚举 $i\in[0,n]$，将所有 $>i$ 的位置填充 $1$，反之填充 $0$。对该 01 序列执行操作，总可以排序为 $0$ 集中在前面 $1$ 集中在后面的串。

证明是显然的。

于是我们枚举所有长度为 $n$ 的 01 串，只要所有串都可以被排好就证明这 $m$ 个数对可以将任意排列都排序。如果存在一个串不行，那么我们也总是可以反向构造一个失败的排列。

### Q2. [AGC006D] Median Pyramid Hard

题面略。

Solution：[Sp's 做题记录：触底是会反弹的？触底是会反弹的！](https://www.cnblogs.com/lemonniforever/p/18431137)，密码为 `zhebuak`。

**这样的 trick 叫做 01 原理。与排序网络等拓展知识相关。**

Ref. [《排序网络》- 符文杰 - IOI2002 国家队候选队论文集](https://github.com/enkerewpo/OI-Public-Library/blob/master/IOI%E4%B8%AD%E5%9B%BD%E5%9B%BD%E5%AE%B6%E5%80%99%E9%80%89%E9%98%9F%E8%AE%BA%E6%96%87/2002/%E7%AC%A6%E6%96%87%E6%9D%B0.pdf)

### Q3. 冒泡排序轮数

> Statement（P4378）：\
> 输入一个排列 $\{p_n\}$，输出把 $\{p_n\}$ 冒泡排序排好序需要的轮数。\
> $1\le n\le 10^7$。

考虑冒泡排序到 $i$ 造成的影响：$[1,i]$ 的前缀 $\max$ 被换到位置 $i$。所以如果 $i$ 前面还有比它大的数，则 $i$ 可以向前移动一步，而前面将减少一个比它大的数。所以冒泡排序一轮可以刻画为所有位置前面比它大的数的个数都减一。

最终状态下所有位置前面都应该有 $0$ 个比它大的数。从而我们的下界是每个数前面比自己大的数的个数次。

或者我们换一个考虑方式，每一轮每个数至多向前一步，所以下界也可以是每个数到自己最终位置的距离的最大值。形式化地，$\max\{p^{-1}_i-i\}$。

### Q4. 双向冒泡排序轮数

> Statement（P4375）：\
> 输入一个排列 $\{p_n\}$，输出把 $\{p_n\}$ 双向冒泡排序（正着扫一次又反着扫一次）排好序需要的轮数。\
> $1\le n\le 10^7$。

我们考虑沿用那个移动前缀最值的刻画。

[会证了，还没写]

### Q5. 同时性 01 序列冒泡排序

> Statement：\
> 给你一个 01 序列 $\{a_n\}$，每次找到所有 $10$ 子串交换，求最少几轮排好序。

首先一个刻画：考虑令 $0$ 为向右走，$1$ 为向上走，得到一条折线。那么原序列逆序对的数量就是折线下方的面积。

利用这个刻画，我们发现每次交换都是削掉折线的一个角，最终削到不存在任何凸起，整个折线“蜗居”在右下角。那么我们考虑所有位置到达右下角的距离，求最大值就是答案。

[picture]

也可以用这个刻画完成 Q4 结论的证明。先使用 01 原理转化，那么就是把每种 01 折线都转成终状态需要的次数最大值。再考虑正着做一次是对所有位置向下推（$1$ 都往后面走了所以折线下降），反着做一次是对所有位置向右推（$0$ 都往前面走了所以折线向右）。

那么你发现每个角每次向右下移动一步。那么所有角走到右下角消失的贡献，是其向下向右距离的 $\max$。

[TBC]

## 2024.9.29 课堂分享

### P5492 [PKUWC2018] 随机算法

### P3226 [HNOI2012] 集合选数

$\rightarrow$ ARC184B。

### P2315 [HNOI2005] 数三角形

### CF914F Substrings in a String

## 2024.10.2 课堂记录 YunQian's contest

### T1 白露澈明之泉

很显然，答案是拿一个全 $1$ 的行去覆盖所有非全 $1$ 的列。

所以首先构造一个全 $1$ 的行。令 $cnt0_i$ 表示第 $i$ 行 $0$ 的数量，$cnt1_i$ 表示第 $i$ 行 $1$ 的数量。则对于第 $i$ 行，将其构造为全 $1$ 的行，至少要 $cnt0_i$ 步。有一种特殊情况，当第 $i$ 行所对应的列上没有 $1$ 时，可以通过找到一个 $1$ 的点。使得能过通过额外的一步构造出来列上的一个 $1$。这种情况下会使步数变成 $cnt0_i+1$。

再考虑将所有列变成 $1$。答案显然是某一列非全 $1$ 的数量。二者相加即为答案。复杂度 $O(n^2)$。

### T2 在空无一物的时光深处

经典 trick。因为有覆盖，所以考虑倒着做。即按照颜色 $n,n-1,\dots,2,1$ 的顺序进行染色。那么此时的染色将会是永久的。

注意到被染色的点连续，考虑区间 DP。

定义状态函数 $f_{l,r,x,0/1}$ 表示对区间 $[l,r]$ 染色，用了 $x,x+1,\dots,n-1,n$ 这些颜色，且刷子在 $l/r$ 时的方案数。

那么有转移方程：

1. $f_{l,r,x,0}\to f_{l',r,x',0}$，向左刷。
2. $f_{l,r,x,0}\to f_{l,r',x',1}$，向右刷。
3. $f_{l,r,x,1}\to f_{l',r,x',1}$，向左刷。
4. $f_{l,r,x,1}\to f_{l,r',x',0}$，向右刷。

因为是倒着来的，所以有：$l'\ne l,r'\ne r$。

这时要求最后一步走的一定是 $c_{x'}-1$ 步，且不能越界。所以只需要关心 $x-1 \sim x'+1$  这些颜色能不能通过左右移动且不超过转移边界（就是不能到一个没被染过的点）的情况下到达某种情况。这玩意跑个背包即可。

这时算法复杂度为 $0(m^2n^2)$，但是空间小炸。发现 $l,r$ 实际上是没有作用的，故能够使用 $len$ 代替 $l,r$。空间复杂度能够接受。

### T3 烟花

原题：P4110

https://www.luogu.com.cn/article/s8um1dj4

考虑从最优解的结构进行观察。

对于连续的 $a,b,c$，我们有：$(1-a)\times b+ (1-b) \times c=b+c-a\times b-c\times b$。交换后两项 $b,c$，此时 $-a \times b$ 变成了 $-a \times c$。所以可以通过将大的 $b$ 交换到前面去实现最优。此时能够通过 $p_i$ 从大到小排序得到最优解存在的顺序，即最优解中任意两项相对顺序一定能够对应到排序后的序列中。

不难发现，这显然是错的（虽然结论正确）。

题目相当于是求一个序列 $P$，使得 $\sum\limits_{i=2}^{k}(1-P_{i-1})P_i$ 最小。则相当于要使 $P_1+\sum\limits_{i=2}^{k} P_{i-1}P_i$ 最大。根据[排序不等式](https://baike.baidu.com/item/%E6%8E%92%E5%BA%8F%E4%B8%8D%E7%AD%89%E5%BC%8F/7775728#:~:text=%E6%8E%92%E5%BA%8F%E4%B8%8D%E7%AD%89%E5%BC%8F%EF%BC%88Rear)可以得到证明，当 $p_i$ 从大到小排序时，存在最有解结构。

但是，如果将所有 $a_i$ 个 $p_i$ 放进去排序后直接跑 DP。显然是会 TLE 的。

考虑继续观察性质。$(1-a)\times b+ (1-b) \times c=b+c-a\times b-c\times b=c+(1-a-c) \times b$。分情况讨论：

1. 当 $(1-a-c)<1$ 时，$b$ 越大越优。
2. 当 $(1-a-c)\ge 1$ 时，$b$ 越小越优。

则最优解中一定不存在相邻 $3$ 项，满足 $x+1 <y \land y+1 < z$。当最有解中不存在下标 $1$ 时，有：$(1-P_1) P_{x_2} \le (1-P_{x_1}) P_{x_2}$，矛盾。所以一定存在下标 $1$。下标 $m$ 同理。

故最优解一定是拿一个前缀和一个后缀拼起来得到的。

然后拿一个双指针就可以了。枚举间隔的时候维护前缀和后缀的最优形式（通过分讨的结论），将所有可能的最优答案取最小即可。该部分复杂度 $O(n)$，总的复杂度 $O(n\log n)$。

### T4 归风

打一下草稿就能发现答案等价与 $(r-l+1)+\min(w+\sum\limits_{i=l}^{r}[a_i >w])$。前面那玩意是定值，只需要求 $\min(w+\sum\limits_{i=l}^{r}[a_i >w])$。

类似于[霍尔定理](https://zhuanlan.zhihu.com/p/460373184)，把式子转化成 $\max(\sum\limits_{i=l}^{r}[a_i\le w]-w)$。那么这个答案等价于给每个点配一个 $a_i \ge j$ 的 $j$ 时最大匹配失配的点数。

由于每个点的点权为 $1$，所以贪心地匹配是正确的。直接模拟即可。

用主席树维护出每个前缀时的最大匹配。查询的时候只需要维护不合法的左部节点 $x$，将 $x$ 删去即可。此时强制使后面的点优先匹配就是对的了。证明很显然吧，因为我们维护的前缀，如果有一个点 $x$ 失配，那么肯定是后面的一个点把它顶掉了，若交换这两个点对答案没有影响。所以只需要考虑删点。复杂度是 $O(n\log n)$ 的。

## 2024.10.2 课堂记录 YunQian's ds

### 线段树分治

[Note](https://www.xht37.com/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%88%86%E6%B2%BB-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/)。

对时间轴进行线段树，相当于在某些区间 $[l,r]$ 中维护一些东西，使得查询转化为单点查询。

#### T1 [CF576E](https://www.luogu.com.cn/problem/CF576E)

对于两次染色的区间 $[x+1,y-1]$，分情况讨论：

1. 已经染色了，则操作不会进行。
2. 并未染色，则该操作有效。

那么对于每个询问，直接查询在某个时刻的单点有效状态即可。使用可撤销并查集能够做到 $O(n\log n\log q)$ 的复杂度。

#### T2 [[Iroha2019 Day4] L](https://www.luogu.com.cn/problem/AT_iroha2019_day4_l)。

考虑将 $\frac{z}{x-y}$ 看成一个斜率。那么问题就可以转化成维护一个凸包。如果将所有点按照 $x$ 排序，那么对于一个插入操作，其对应的点上的凸包，只需要弹出某些末尾节点就是对的。此时只需要在插入的同时维护查询。对于查询，在单点上拿一个指针维护出最大值即可。复杂度是 $O(n \log n)$ 的。

因为是绝对值，所以要正反跑 $2$ 遍。

#### T3 [YDRG005 D](https://yundouxueyuan.com/p/YDRG005D)。

【空】

#### T4 [P10611](https://www.luogu.com.cn/problem/P10611)。

先考虑 $b_j=1$ 怎么做。

将覆盖转化成插入一个连续段，删除一个连续段。

考虑使用树套树维护。对于一个插入操作，找到行后通过区间插入进行维护。内层的线段树需要支持插入，删除，求区间 $\max$。

若查询的 $l=r$，直接查询就行了。现在询问变成了查询一个区间，那么再在外层的树上维护一个区间 $\max$。

这个时候可以发现，能够直接用 $2$ 棵线段树，一个维护行，一个维护列就能得到答案。

考虑将线段树分开之后，得到若干连续的行形成的 $k\times m$ 的矩形于若干连续的列形成的 $n\times w$ 的矩形的交即为询问的 $k \times w$ 的区间子矩形，在两棵线段树上分别维护插入，删除，区间 $\max$ 即可。（怎么维护？？？）

现在考虑 $b_j \ne 1$ 的情况。

毁了，不会。

### 2024.10.3 课堂记录 YunQian's ds

#### T1 [QOJ3998](https://qoj.ac/problem/3998)

简要题意：

> 有 $n$ 个物品，每个物品有重量 $w_i$ 和价值 $v_i$。定义 $f(i)$ 表示用大小为 $i$ 的背包最多能装多少价值的物品。\
给定 $E$，你需要删除一个区间 $[l,r]$ 内的所有物品，使得只考虑剩下的物品时，有 $\frac{(f(1)+f(2)+...+f(k))}{k} \leq E$。在此基础上，最小化 $r - l + 1$。

---

#### T2 [P4234](https://www.luogu.com.cn/problem/P4234)

首先按照边权从小到大排序，要求最大边权减最小边权最小，我们可以直接上双指针，用 LCT 动态删边/加边。复杂度 $\Theta(n \log^2 n)$。

这里 YunQian 给了一个三 $\log$ 的做法。考虑二分答案，可以双指针得到每一条边被删除/加入的时间戳，直接上线段树分治，判断能否出现生成树。

#### T3 [QOJ5020](https://qoj.ac/problem/5020)

#### T4 [P5311](https://www.luogu.com.cn/problem/P5311)



#### T5 [P7126](https://www.luogu.com.cn/problem/P7126)



#### T6 [P9527](https://www.luogu.com.cn/problem/P9527)



#### T7 [P9340](https://www.luogu.com.cn/problem/P9340)

#### T8 [YDRS004E](https://yundouxueyuan.com/p/YDRS004E)

#### T9 [QOJ8547](https://qoj.ac/problem/8547)

简要题意：

> 给定一棵 $n$ 个点的树和正整数 $k$。定义 $S(x)$ 表示和 $x$ 距离不超过 $k$ 的点的集合。$q$ 次询问，每次给 $l,r$，查询 $S(l) \cup S(l+1) \cup \dots \cup S(r)$ 的大小。

---

如果我们选择对于每一个 $l \leq i \leq r$，每一个数的 $k$ 邻域点的点的数量加起来然后去重，是没有前途的。考虑对于每一个数判断它的 $k$ 邻域点是否任意一个在 $[l,r]$ 区间中。

将询问离线，按照 $r$ 排序。令 $Max_u = x$ 表示最大的 $x$ 满足 $x \in S(u) \wedge x \leq u$。最后答案就是求有多少个 $Max_u \geq l$。

考虑每一次询问更新 $r$ 之后 $Max_u$ 怎么维护。考虑对于树上 $r$ 的祖先分层考虑，对于每一层满足条件的节点在 BFS 序上是连续的。

因此预处理 $L_{i,j}$ 表示 $i$ 在 BFS 序上能到最左的点使得它们两点之间的距离不超过 $j$；$R_{i,j}$ 同理。转移是平凡的。我们在添加一个 $r$ 时，我们一个点一个点的往上跳 $k$ 次，设当前跳到的点为 $u$。

我们将 $[L_{u,k - dist_{r,u}},R_{u,k - dist_{r,u}}]$ 推平，同时注意到 $k - dist_{r,u} - 1$ 这一层也是没被完全更新的，所以将这一层也推平。这样会将一些节点重复覆盖，但是并不影响结果，所以就无所谓了。

可以上 ODT 做到复杂度 $\Theta((nk + q) \log n)$，注意查询要用树状数组，已经对于一个点没有 $k$ 级祖先的处理。


#### T10 [LOJ6669](https://loj.ac/p/6669)

显然我们需要用 $1$ 号点将其它 $n - 1$ 个点全部查询一下，得到每一个点的 $dep$。

我们将所有点对 $dep$ 分层。深度为 $d$ 的节点的父亲只能在深度 $d - 1$ 的节点中。暴力询问要花 $\Theta(n^2)$ 次。

设我们正在处理深度为 $d$ 的节点，对前 $d - 1$ 层树剖。我们跳到重链的底端 $u$，询问当前层的节点 $v$。如果 $dist(u,v) = 1$，则 $v$ 的父亲就是 $u$；否则由 $dist(u,v) = dep_u + dep_v - 2 \cdot dep_{lca(u,v)}$，可以推导出 $lca(u,v)$，然后从 $lca$ 再从轻边跳下去即可。由于最多只会跳 $\Theta(\log n)$ 条轻边，所以查询次数是 $\Theta(n \log n)$ 次。

因为是二叉树，所以是卡不满的，可以证明上界是 $29970$ 次，但是我不会。

#### T11 [P9999](https://www.luogu.com.cn/problem/P9999)

## 2024.10.03 课堂分享

### T1 [HDU7544](https://vjudge.net/problem/HDU-7544)

### T2 [P8492](https://www.luogu.com.cn/problem/P8492)

### T3 [P10064](https://www.luogu.com.cn/problem/P10064)

### T4 [P4581](https://www.luogu.com.cn/problem/P4581)

### T5 [P10832](https://www.luogu.com.cn/problem/P10832)

### T6 [CF1365G](https://www.luogu.com.cn/problem/CF1365G)

### T7 [CF1290E](https://www.luogu.com.cn/problem/CF1290E)

### T8 [CF1810F](https://www.luogu.com.cn/problem/CF1810F)

### T9 [AT_agc028_f2](https://www.luogu.com.cn/problem/AT_agc028_f2)

## dottle：构造——人类群星闪耀时

### 1.鸽巢原理

[CF1450C2](https://www.luogu.com.cn/problem/CF1450C2)

![](https://cdn.luogu.com.cn/upload/image_hosting/tezegham.png)

不难发现，这样满足题目要求。

三种颜色的格子分别按照 $(i+j) \bmod 3$ 分为 $3$ 类。只需要满足一类格子全是 `X/O` ，存在另一类格子全是 `O/X` 即可。

$3$ 类格子，从中选 $2$ 个，每两个存在 $2$ 种方案，一共有 $6$ 种修改方案，且总修改数量为 $2k$。

根据抽屉原理，最少的一种修改方案最多为 $\lfloor{\dfrac{3}{k}} \rfloor$ 次。

```
const int N = 305;
char s[N][N], ch[3], c[N][N];
int n, k;
bool work() {
    int cnt = 0;
    R(i, 1, n) {
        R(j, 1, n) {
            c[i][j] = s[i][j];
            if (s[i][j] == '.' || ch[(i + j) % 3] == '.') continue;
            if (s[i][j] != ch[(i + j) % 3]) ++cnt, c[i][j] = ch[(i + j) % 3];
        }
    }
    if (cnt <= k / 3) {
        R(i, 1, n) {
            R(j, 1, n) printf("%c", c[i][j]);
            ptc('\n');
        }
        return 1;
    }
    return 0;
}
void solve() {
    cin >> n; k = 0;
    R(i, 1, n) scanf("%s", s[i] + 1);
    R(i, 1, n) R(j, 1, n) if (s[i][j] != '.') ++k;
    ch[0] = '.', ch[1] = 'X', ch[2] = 'O'; if (work()) return ;
    ch[0] = '.', ch[1] = 'O', ch[2] = 'X'; if (work()) return ;
    ch[0] = 'X', ch[1] = '.', ch[2] = 'O'; if (work()) return ;
    ch[0] = 'X', ch[1] = 'O', ch[2] = '.'; if (work()) return ;
    ch[0] = 'O', ch[1] = '.', ch[2] = 'X'; if (work()) return ;
    ch[0] = 'O', ch[1] = 'X', ch[2] = '.'; if (work()) return ;
}

signed main() {
    int T; cin >> T;
    while (T--) solve();   
    return 0;
}
```

### 2.dfs树

[P5811](https://www.luogu.com.cn/problem/P5811)

**Hint**. 不妨设 $a\le b\le c$，你觉得哪个部分不必要是连通块。先思考树上的情况。

首先注意到我们一定能够从连通块中不断删点得到更小的连通块，染出两个大小为 $a,b$ 的连通块显然是更简单的。所以问题转化成把原图划分成两个连通块，一个大小至少 $a$，一个大小至少 $b$。

先考虑树上的情况，显然枚举每一条树边，并判断两端大小是否满足即可。

转到图上，可以先跑一边 DFS 树，转为树上的情况，若存在一条树边满足则直接输出答案。

否则，考虑重心的每个子树。注意到 $b\le \dfrac{n}{2}$，而重心具有 $\forall siz \le \dfrac{n}{2}$ 的性质，如果重心的一个子树 $siz \ge a$，则 $n-siz\ge \dfrac{n}{2} \ge b$，一定在前面已经被判定为合法。所以，重心连接的所有子树一定 $siz < a$。

如果一个子树内没有连向重心祖先的返祖边，则这个子树必然和重心属于同一个连通块（否则无法让这棵子树所在连通块大小 $\ge a$）。

把所有这样的子树和重心合成一个连通块，如果这个连通块的大小大于 $n-a$ 则无解。

否则构造一个初始解，重心的子树放在 $B$ 集合，其余部分放在 $A$ 集合。

显然 $|B|>n-a,|A|<a$。依次把 $B$ 集合中，所有有连向重心祖先返祖边的子树移到 $A$ 集合中，直到 $|A|\ge a$ （等价于 $|B| \le n - a$）为止。此时 $|A|\ge a,|B|\le n-a$ ，现在只需满足 $|B|\ge b$ 即可。

可以证明这样的到的 $|B|\ge b$。注意到 $B$ 集合中子树大小都 $<a$，对于 $|B|$ 从 $>n-a$ 变为 $\le n-a$ 的一次变换，变换后的 $|B| > n-a-a>n-a-b=c\ge b$ 。得证。

在实现时可以用 $low$ 数组判断返祖边，注意输出时根据调换的 $a,b,c$ 调整输出。

```
const int N = 3e5 + 5;
int n, m, A, B, C, rt, idx, sz[N], mx[N], ans[N], pa[N], low[N], dfn[N];
bool vis[N];
vector <int> E[N], G[N];
void dfstree(int x) {
    dfn[x] = low[x] = ++idx; 
    for (int v : G[x]) {
        if (vis[v]) {
            low[x] = min(low[x], dfn[v]);
            continue;
        }
        vis[v] = 1;
        E[x].push_back(v), E[v].push_back(x);
        pa[v] = x;
        dfstree(v);
        low[x] = min(low[x], low[v]);
    }
}
void init(int x, int fa) {
    sz[x] = 1; 
    for (int v : E[x]) {
        if (v == fa) continue;
        init(v, x);
        sz[x] += sz[v];
        mx[x] = max(mx[x], sz[v]);
    }
    mx[x] = max(mx[x], n - sz[x]);
    if (!rt || mx[x] < mx[rt]) rt = x;
}
void color(int x, int fa, int col, int &siz) {
    if (!siz || vis[x]) return ; 
    vis[x] = 1;
    ans[x] = col, --siz;
    for (int v : E[x]) {
        if (v == fa) continue;
        color(v, x, col, siz);
    }
}
vector <int> son1, son2;
int id[4];
void print() {
    R(i, 1, n) printf("%d ", id[ans[i]]);
    exit(0);
}
signed main() {
    read(n, m, A, B, C);
    if (A <= B && B <= C) id[1] = 1, id[2] = 2, id[3] = 3;
    else if (A <= C && C <= B) id[1] = 1, id[2] = 3, id[3] = 2;
    else if (B <= A && A <= C) id[1] = 2, id[2] = 1, id[3] = 3;
    else if (B <= C && C <= A) id[1] = 2, id[2] = 3, id[3] = 1;
    else if (C <= A && A <= B) id[1] = 3, id[2] = 1, id[3] = 2;
    else id[1] = 3, id[2] = 2, id[3] = 1;
    if (B > C) swap(B, C);
    if (A > B) {
        swap(A, B);
        if (B > C) swap(B, C);
    }
    R(i, 1, m) {
        int u, v; read(u, v); ++u, ++v;
        G[u].push_back(v), G[v].push_back(u);
    }
    vis[1] = 1;
    dfstree(1); 
    memset(vis, 0, sizeof vis); R(i, 1, n) ans[i] = 3;
    init(1, 0); 
    R(i, 1, n) {
        if (sz[i] >= A && (n - sz[i]) >= B) color(i, pa[i], 1, A), color(pa[i], 0, 2, B), print();
        else if ((n - sz[i]) >= A && sz[i] >= B) color(i, pa[i], 2, B), color(pa[i], 0, 1, A), print();
    }
    for (int v : E[rt]) {
        if (v == pa[rt]) continue;
        if (low[v] < dfn[rt]) son1.push_back(v);
        else son2.push_back(v);
    }
    int sum = 1;
    for (int v : son2) sum += sz[v];
    if (sum > n - A) {
        R(i, 1, n) printf("%d ", 0);
        return 0;
    }
    int oa = A;
    color(pa[rt], rt, 1, A); 
    sum = sz[rt];
    for (int v : son1) {
        sum -= sz[v];
        color(v, rt, 1, A);
        if (sum <= n - oa) break;
    }
    color(rt, pa[rt], 2, B);
    print();
    return 0;
}
```

[CF1205D](https://www.luogu.com.cn/problem/CF1205D)

**Hint**. 对数字敏感一些，$\dfrac{2n^2}{9}$ 可以分解成什么？ 

令 $ c $ 为树的重心。以 $ c $ 为根节点，令 $ s_1, s_2, \dots, s_k $ 成为其子节点的子树大小。由重心的性质， $ s_i \le \frac{n}{2}$ 。我们可以将子节点的子树分成两组，使得每组的大小至少为 $ \lceil \frac{n-1}{3} \rceil $ 。

证明：若至少有 $ 4 $ 棵子树，则其中一定存在两棵的顶点总数不超过 $ \frac{n}{2} $ 个，然后将它们合并。当剩下 $ 3 $ 棵子树时，我们令 $a, b, c$ 为 $3$ 棵子树的大小，有 $a\le b\le c, a+b+c=n-1$， 将两棵较小的子树 $a,b$ 合并为一组，不难发现 $a+b=n-c-1 \ge n-1-\frac{n}{2} \ge \lceil \frac{n-1}{3} \rceil$，$c\ge \lceil \frac{n-1}{3} \rceil$。

（实际上，我们将 $s$ 排序后，选取一段前缀直到 $sum\ge \lceil \frac{n-1}{3} \rceil$ 即可。）

令第一组有 $A$ 个顶点，第二组有 $ B$ 个顶点。们将数字放在 $A$ 中以及 $ c $ 和 $A$ 之间的边上，使 $ c $ 到第一组顶点的距离为 $ 1, 2, \dots, A $ 。类似地，我们使从 $ c $ 到第二组顶点的距离等于 $ (A + 1), 2 (A + 1), \dots, B (A + 1) $ 。显然从 $ 1 $ 到 $ (A + 1) (B + 1) -1 $ 的每个数字都可以作为第一组中某个顶点与第二组中某个顶点之间的距离。接下来只需证明$ (A + 1) (B + 1) -1 $ $\ge$ $ \frac {2n ^ 2} {9} $ 。

证明：$f(A)=(A+1)(B+1)-1=(A+1)(n-A)-1=-A^2+(n-1)A+n-1$ 是一个关于 $A$ 的开口向下的二次函数，在定义域内最小值在 $\frac{n-1}{3}$ 取得，此时 $f(A)=(\frac{n + 2 }{3}) (\frac{2n + 1}{3}) - 1 = \frac{2n ^ 2 + 5n + 3}{9} - 1 \ge \frac{2n ^ 2}{9}$。

```
const int N = 1e6 + 5;
int n, rt, sz[N];
vector <int> E[N];
void init(int x, int fa) {
    sz[x] = 1; int mx = 0;
    for (int v : E[x]) {
        if (v == fa) continue;
        init(v, x);
        sz[x] += sz[v];
        mx = max(mx, sz[v]);
    }
    mx = max(mx, n - sz[x]);
    if (mx * 2 <= n) rt = x;
}
int dfn[N], lst, tot, val;
void dfs(int x, int fa) {
    sz[x] = 1; 
    for (int v : E[x]) {
        if (v == fa) continue;
        dfs(v, x);
        sz[x] += sz[v];
    }
}
vector <tuple <int, int, int> > ans;
void dfs2(int x, int fa) {
    dfn[x] = ++tot;
    ans.push_back({fa, x, (dfn[x] - dfn[fa]) * val});
    for (int v : E[x]) {
        if (v == fa) continue;
        dfs2(v, x);
    }
}
signed main() {
    cin >> n; if (n == 1) return 0;
    R(i, 1, n - 1) {
        int u, v; cin >> u >> v;
        E[u].push_back(v), E[v].push_back(u);
    }
    init(1, 0); dfs(rt, 0);
    sort(E[rt].begin(), E[rt].end(), [&](int x, int y) {return sz[x] < sz[y];});
    int sum = 0; int lim = ceil((n - 1) * 1.0 / 3); int pos;
    for (int i = 0; i < E[rt].size(); ++i) {
        int v = E[rt][i];
        sum += sz[v];
        if (sum >= lim) {pos = i; break;}
    }
    val = 1;
    for (int i = 0; i <= pos; ++i) dfs2(E[rt][i], rt); val = sum + 1; tot = 0;
    for (int i = pos + 1; i < E[rt].size(); ++i) dfs2(E[rt][i], rt);
    for (auto t : ans) cout << get<0>(t) << ' ' << get<1>(t) << ' ' << get<2>(t) << '\n';
    return 0;
}
```



[uoj670](https://uoj.ac/problem/670)

[sol](https://www.cnblogs.com/apjifengc/p/17306139.html)

### 3.图上构造

[CF1270G](https://www.luogu.com.cn/problem/CF1270G)

将题目中的条件移项得到 $1\le i-a_i\le n$，这启示我们使用 $i-a_i$。

$i$ 向 $i-a_i$ 连边，输出图中任意一个环即可。

证明：

设 $S$  为图中一个环对应的点集。

$ S $ 形成了环，则 $ \sum_{i\in S}i=\sum_{i\in S}i-a_i $ 。

移项得 $\sum a_i=0$。

本题在场上卡了一众高手（tourist,jiangly,benq等)，虽然感觉也没有那么难。

```
const int N = 1e6 + 5; 
int n, a[N], to[N];
bool vis[N];
void solve() {
    cin >> n;
    R(i, 1, n) cin >> a[i], to[i] = i - a[i], vis[i] = 0;
    vector <int> ans;
    int now = 1;
    while (!vis[now]) {
        vis[now] = 1;
        now = to[now];
    }
    ans.push_back(now); now = to[now];
    while (now != ans[0]) ans.push_back(now), now = to[now];
    cout << ans.size() << '\n';
    for (int i = 0; i < ans.size(); ++i) cout << ans[i] << ' '; cout << '\n';
}
signed main() {
    ios :: sync_with_stdio(0); cin.tie(0), cout.tie(0);
    int T = 1; cin >> T;
    while (T--) solve();
    return 0;
}
```

### 4.归纳法

[ARC122E](https://www.luogu.com.cn/problem/AT_arc122_e)

使用归纳法。

对于 $n>1$，我们考虑找出这个序列的最后一个数。

最后一个数需要满足前面数的 $\operatorname{lcm}$ 不是它的倍数，也就是说 $a_i \not \mid \operatorname{lcm}_{j \ne i }a_j$。

这个式子相当于 $\operatorname{gcd}(a_i,\operatorname{lcm}_{j \ne i }a_j) < a_i$。

但是 $\operatorname{lcm}$ 太大，把式子转化一下。

$\operatorname{lcm}_{j\ne i}\{\gcd(a_j,a_i)\}< a_i $ 。

满足这个式子的 $a_i$ 则可以作为序列的最后一个数，注意到 $\operatorname{lcm}$ 随着问题规模的减小不会上升，故找到一个可行的 $a_i$ 就放入答案是正确的。问题变为规模为 $n-1$ 的问题，递归即可。

```
#define int ll
const int N = 500 + 5;
int n; 
vector <int> ans;
int lcm(int x, int y) {return x / __gcd(x, y) * y;}
void solve(vector <int> v) {
    if (v.size() == 1) return ans.push_back(v[0]), void();
    R(i, 0, v.size() - 1) {
        int L = 1;
        R(j, 0, v.size() - 1) {
            if (i == j) continue;
            L = lcm(L, __gcd(v[i], v[j]));
        }   
        if (L < v[i]) {
            ans.push_back(v[i]);
            vector <int> t; 
            R(j, 0, v.size() - 1) if (i != j) t.push_back(v[j]);
            solve(t);
            return ;
        }
    }
    puts("No"); exit(0);
}
signed main() {
    cin >> n; vector <int> v(n);
    R(i, 1, n) cin >> v[i - 1];
    solve(v);
    reverse(ans.begin(), ans.end());
    puts("Yes");
    for (int x : ans) cout << x << ' ';
    return 0;
}
```

[CF1637G](https://www.luogu.com.cn/problem/CF1637G)

略。

### 5.构造思想的应用

[CF1658F](https://www.luogu.com.cn/problem/CF1658F)

首先，令 $a,b$ 分别为 $0,1$ 的个数。那么 $1$ 的数量 $cnt=\dfrac{bm}{n}$。若 $bm$ 不为 $n$ 的倍数无解。

将数组首尾连接为一个环。

给出一个结论：在环上一定有一个长度为 $m$ 符合条件的区间，故答案上界为 $2$。

给出一个观察：设 $c_i =$ $s[i \dots i + m - 1]$ 中 $\texttt{1}$ 的数量（此处数组首位连接为环形数组）。

不难发现有 $|c_i-c_{i+1}| \leq 1$ ，并且对于所有 $y$ 满足 $min(c_i) \leq y \leq max(c_i)$ ，存在 $c_i = y$ 。

若所有子串都小于/大于整串密度显然是不可能的，根据上面的观察，中间必然经过一个字串密度等于原串密度。

```
#define int ll
const int N = 4e5 + 5;
int n, m, s[N];
void solve() {
    cin >> n >> m; int a = 0, b = 0;
    R(i, 1, n) {
        s[i] = s[i - 1];
        char c; cin >> c;
        if (c == '0') ++a;
        else ++b, s[i]++;
    }
    if (b * m % (a + b)) return puts("-1"), void();
    R(i, m, n) {
        int cnt = s[i] - s[i - m];
        if (b * m == cnt * n) {
            cout << 1 << '\n';
            cout << i - m + 1 << ' ' << i << '\n';
            return ;
        }
    }
    R(i, 1, m - 1) {
        int cnt = s[i] + s[n] - s[n - (m - i)];
        if (b * m == cnt * n) {
            cout << 2 << '\n';
            cout << 1 << ' ' << i << '\n';
            cout << n - (m - i) + 1 << ' ' << n << '\n';
            return ;
        }
    }
}
signed main() {
    int T; cin >> T;
    while (T--) solve();    
    return 0;
}
```

[CF1622F](https://www.luogu.com.cn/problem/CF1622F)

发现答案下界是 $n-3$。

以下设 $B$ 为去掉的数的集合。

$$
\prod\limits_{i=1}^{2k}i! =
2^kk!
\left(\prod\limits_{i=1}^{k}(2i-1)!\right)^2
$$

$n\equiv0\pmod{4}$ 时，取 $B=\{\frac{n}{2}\}$ 即可。

$n\equiv2\pmod{4}$ 时，取 $B=\{2,\frac{n}{2}\}$ 即可。

$n\equiv1\pmod{2}$ 时，去掉 $n!$ 这项后规模减小 $1$，成为偶数，变为上述两种情况。

## 2024.10.6 模拟赛

### T1 饼干

首先显然的是 $sum \bmod 2 = 1$ 一定无解。

注意题目限制 $2 \times \max\{b_{i,j}\} = \sum{b_{i,j}}$，直接看作选出一个 $\max$ 消掉其它的数。也就是说将所有数分为两个集合，使得每一个集合的和为 $\frac{sum}{2}$。这样后一个集合就能把前一个集合全部消除。

但是由于每一轮相同位置 $j$ 不能存在于同一个集合，所以当 $\max\{a_i\} > \frac{sum}{2}$ 时也是无解的。

考虑消除时从大到小，因为每一个大的数一定可以消除一个小的数，所以每一轮都至少可以消除两个数，是小于 $\lceil \frac{n}{2} \rceil$ 的次数限制的。实现可以直接双指针。

### T2 狂人日记

打表找规律或者归纳法证明可以得到 $q(n)=2^{\text{popcount}(n)}-1$，于是题目可以转化为 $1\sim m$ 有多少个数的 $\text{popcount}=|t|$，其中 $t$ 必须全为 $1$，因为答案形如 $2^k-1$。

类似数位 DP 的遍历过程，考虑固定前 $i$ 个位置固定，后面位置全为 $0$，求小于等于当前数的答案数量，组合数计算即可。

### T3 倒卖文物

设 $d_i=\prod\limits_{j=1}^{i-1}a_j$，且 $f_{i,j}$ 表示使用前 $i$ 种数并且和为 $(m \bmod d_{i+1})+j\times d_{i+1}$ 的方案数。

首先观察状态数，不难发现对于 $i$ 来说，$j$ 的上界为 $\sum\limits_{k=1}^{i-1}b_k\frac{d_k}{d_i}$，最坏情况下为 $20\times b_i+\frac{1}{2}\times 20\times b_i+\frac{1}{4}\times 20\times b_i+\frac{1}{8}\times 20\times b_i\cdots =40\times b_i$，故总状态数为 $40\sum\limits b_i$。

基于 $\left\lfloor \frac{\left\lfloor \frac{a}{b} \right\rfloor}{c} \right\rfloor=\left\lfloor \frac{a}{bc} \right\rfloor$，可以将高精除法转化为高精除单精。

### T4 Snakes 的 Naïve Graph

考虑 $G(m)$ 的二分图形态是，相同编号的左右部点之间都有一条直连边，编号互为模 $m$ 意义下逆元的左右部点且编号不同的点（即 $xy\equiv 1\pmod m\land x\ne y$ 的左部 $x$ 和右部 $y$、左部 $y$ 和右部 $x$）之间有一条边。

由于一个数不可能有两个逆元，这在最终的二分图中将体现为若干个点不相交的四元环结构（左部 $x$ 到右部 $y$ 和右部 $y$ 到左部 $x$ 都有边）。

考虑计数最大匹配。显然通过全选直连边，可以得到这个二分图的最大匹配是满配。考虑放弃一些直连边，那么空出来的点必须使用四元环重新连接上。所以最大匹配的形态一定是放弃一些直连边，增加一些四元环，又因为四元环互不相交所以任意选择一个四元环的子集都一定可以调整出来。所以假设四元环的数量是 $c$，最大匹配数量就是 $2^c$。

考虑四元环的数量。显然我们更容易计数 $2c$，也就是四元环上非特殊边的数量。每个与 $m$ 互质的数因为存在逆元都可以贡献，但每个模 $m$ 意义下 $1$ 的二次剩余又都会贡献成重边要去掉。所以令 $f(i)$ 表示 $[1,m)$ 范围内模 $m$ 意义下 $1$ 的二次剩余数量，$2c$ 其实就是 $\varphi(m)-f(m)$。假设我们能够快速预处理出 $f(m)$，那么预处理 $c$ 和 $2^c$ 的前缀和并处理询问都是 trival 的。

令 $f(1)=1$ 后容易发现 $f$ 是一个积性函数，这使得我们可以直接线性筛。

> Proof by yzc2005：  
> 考虑

考虑 $f$ 在质数及质数幂处的取值。根据二次剩余的性质（欧拉准则），对于任意奇质数 $p$ 都存在 $f(p)=2$。此外，容易发现对于奇质数 $p$ 的幂次 $p^k$ 处也都存在 $f(p^k)=2$。对于 $2$，首先存在 $f(2)=1,f(4)=2$，对于 $2^k,k\ge 3$，都存在 $f(2^k)=4$。

> 证明奇质数幂次处的 $f$ 为 $2$ by yzc2005：  
> 考虑 $x^2\equiv 1\pmod {p^k}$ 可以写成 $(x+1)(x-1)\equiv 0\pmod {p^k}$。由于 $\gcd(x+1,x-1)$ 为 $1$ 或 $2$，所以对于 $p>2$ 两者不可能同时贡献 $p$ 因子。所以解只存在 $x\equiv \pm 1\pmod{p^k}$。

于是可以直接改一下线性筛筛出 $f$，具体比较麻烦的是需要记录一下每个数里面 $2$ 的数量来确定 $2$ 的贡献，其他都是 trival 的。

## 2024.10.6 课堂记录

### 容斥原理

有 $n$ 个谓词 $P_{1\sim n}$，同时设 $Q_i=\overline{P_i}$, 求有多少个对象 $X$ 满足 $\forall i,P_i(X)=1$。

我们求的东西为：

$$
\begin{matrix}
&\sum\limits_X\prod\limits_{i=1}^n[P_i(X)]\\
=&\sum\limits_X\prod\limits_{i=1}^n(1-[Q_i(X)])\\
=&\sum\limits_X
\end{matrix}
$$

wait……

关键在于观察到需要容斥的条件在哪里

### T1 [O(rand)](https://www.luogu.com.cn/problem/AT_tokiomarine2020_e)

### T2 [Span Covering](https://www.luogu.com.cn/problem/AT_dwacon6th_prelims_e) 

有 $X$ 个谓词为 $i$ 是否被覆盖，可以枚举状态 $s$ 容斥掉 $s$ 中的点不被覆盖的方案数。

## 2024.10.06 课堂分享

### [AGC001E](https://www.luogu.com.cn/problem/AT_agc001_e)

### AGC002E

### 

## 2024.10.7 yzc2005 容斥选讲

### [P3349 [ZJOI2016] 小星星](https://www.luogu.com.cn/problem/P3349)

考虑 dp，$f_{i,S,x}$ 表示子树 $i$ 内使用掉的 $p$ 的集合为 $S$，且 $p_i=x$ 的子树内部合法方案数。转移需要进行子集卷积（要求 $S\cap T=\emptyset$），直接搞复杂度看上去是 $\mathcal O(n^33^n)$ 的，但是跑不满且可以进行若干优化：

- 不需要枚举所有子集。因为所有集合的 `popcount` 都是固定的，并且 $S\cap T=\emptyset\iff |S\cup T|=|S|+|T|$ 所以对于 $|S|+|T|$ 的集合大小只可以来自于交集为空的情况。这样就可以直接用 FWT 做按位或卷积然后只取 $|S|+|T|$ 这一个 `popcount` 的答案出来用。

这样做复杂度可以做到 $\mathcal O(n^32^n)$，然而由于常数无法稳定通过。

考虑容斥掉排列选择。排列等价于 $n$ 个条件，每个 $i\in[1,n]$ 都需要在这个长度为 $n$ 的序列中出现。所以不妨枚举允许出现的数集，然后 $f_{i,x}$ 表示在 $i$ 的子树内且 $p_i=x$ 的子树内部合法方案数，这可以做到 $\mathcal O(n^3)$，从而复杂度做到 $\mathcal O(n^32^n)$，可以通过。

### 应用

#### 莫比乌斯反演

$\mu(d)$ 本质上是 $d$ 质因子集合 $|P|$ 的容斥系数 $(-1)^{|P|}$，相当于钦定一个质因子集合整除 $d$。

#### 子集反演

没写完。

#### Matrix-Tree 定理

跳过了。

### 技巧

#### 等量代换

将所求的式子中某一个量改成另一个更容易处理的量，然后交换求和式。

> 给定 $n$ 个点的树，每个点以 $p_i$ 的概率被删除，求期望连通块数。
>
> 点减边 trick，计算点数的期望和边数的期望即可。点数的期望就是 $\sum(1-p_i)$，边数的期望就是 $\sum\limits_{(i,j)\in E}(1-p_i)(1-p_j)$。
>
> 也可以搞成有根树放到最高点上计数。本质也是点减边。

### [P7324 [WC2021] 表达式求值](https://www.luogu.com.cn/problem/P7324)

首先，表达式树。

$\mathcal O(nm|E|)$ 的 $70$ 分做法只需要每一位拆开做，然后离散化成 $0\sim 9$，在表达式树上进行树形 dp 每个值的方案数就行，并不难想。

对于正解，我们继续拆位每一位独立开做。

考虑所有数列中这一位上的 $m$ 个值，每个都值可以拆成比自己小的值之间的间隔的和（差分的前缀和）。这促使我们尝试统计所有的间隔对答案的贡献。考虑枚举间隔，由于只关心大小关系，所以应用 01 原理，大小在间隔前面的变量成为 $0$，大小在间隔后面的变量成为 $1$，使用一个树形 dp 计数最终根上是 $1$ 的方案数，这就是这个间隔在最终和中的贡献次数。

那么直接 $\mathcal O(2^m)$ 枚举所有变量位置上可能的 $0,1$ 集合然后加一个 $\mathcal O(|E|)$ 树形 dp 进行预处理。这样每一位上都可以直接先枚举间隔再根据取值之间的大小关系查询预处理出来的表，这样做到 $\mathcal O(2^m|E|+n\text{poly}(m))$ 就能过了。

### [[ARC163D] Sum of SCC](https://www.luogu.com.cn/problem/AT_arc163_d)

首先，竞赛图强连通分量的数量就是缩点后链的长度。

[这个没搞懂，之后再填]

### [[ARC082E] ConvexScore](https://www.luogu.com.cn/problem/AT_arc082_e)

权值比较离谱，考虑怎么凑出来。

考虑 $2^k$ 的组合意义就是凸包里面的所有点选或者不选的方案数。

[没写完，To be continued]

### [CF1605F](https://www.luogu.com.cn/problem/CF1605F)

先考虑判定性。

你考虑一个 PalindORme 的序列就是从两头开始往中间或起来一样的序列。那么你回到 good 的序列上，可以看成是每次删掉两个和目前前后缀或起来相等的数，只要能删空或者删到只剩一个就 good。

注意到即便有很多个数可以选择随便选一对也无所谓，因为前面能用的后面还能用，所以这个判定直接就是充要的。

考虑数不 good 序列的数量。那么它一定存在一个前后缀位置 $i$ 找不到和目前前后缀或起来相等的数从而不 good。可以发现，一个不合法序列一定是 $2i$ 的合法序列拼上中间一堆垃圾（这堆垃圾去掉两边的或之后一定任意数不为 $0$ 且两两不同），这样就有了一个转移的结构。

考虑我们只关心二进制的 `popcount`。$f_{i,j}$ 表示长度为 $i$，[没写完，To be continued]

### [LOJ3911「PA 2022」Drybling Bajtessiego](https://loj.ac/p/3911)

首先 $\mathcal O(n^4)$ 暴力是简单的。

考虑建立双射来取得唯一性。

### ARC154E

skipped

### QOJ970

首先考虑一组询问怎么做。容易想到先二分 $W$ 来交换维度，可以转成确定 $W$ 求最大的 $k$。

容易发现，最小值一定会被选，容易反证证明。

然后考虑 $\min$ 分治，左边的 $\min$ 和右边的 $\min$ 也是要选的。注意这样并不等价于选择前 $k$ 小。这样模拟不太方便所以我们换一种刻画，考虑从小往大看数，如果能放进去就直接放进去，容易发现这是和 $\min$ 分治等价的。然后我们发现小于等于 $\frac{W}{2}$ 的数总是可以直接放进去，大于 $\frac{W}{2}$ 的数看一下周围是否已经有大于 $\frac{W}{2}$ 的数，或者两边小于等于 $\frac{W}{2}$ 的数是否让它爆了就行。

也可以考虑相邻和限制的经典 trick，我们把所有数划分成两半，一半小于等于 $\frac{W}{2}$，另一半大于 $\frac{W}{2}$。显然小于等于 $\frac{W}{2}$ 的数我们可以全部选上，而它们两两之间一定是选择一个最小的大于 $\frac{W}{2}$ 的数（基于人类的朴素价值观贪心）。这样刻画也很方便。

然后考虑多组询问。首先直接整体二分。我们拿一个  `set` 维护所有小于等于 $\frac{W}{2}$ 的元素的集合和两两之间的最小值（前提是可用）。那么我们每次可以扫值域区间操作 `set` 并维护两两之间的可用最小值，还需要一个数据结构来查询 RMQ 以添加两两间大于 $\frac{W}{2}$ 的数中的最小值。（这里还没有完全搞清楚）

### CF1396E

饿死了，没听

### PKUSC2022 D2T2 Colorful Tree

考虑路径上要么出现一种颜色的全部要么不出现一种颜色，我们想随机异或哈希。那么一条路径的权值就变成它的异或和，权值为 $0$ 的路径合法。异或和带来了美丽的性质：$u\to v$ 的权值就是 $u\to 1$ 的权值异或上 $v\to 1$ 的权值。所以我们直接预处理 $1\to i$ 的边权异或和 $v_i$，那么合法路径就是 $v_i$ 相同的点的路径。

现在问题转变为查询不经过一个点的同色路径的最长长度。可能存在虚树或点分治的做法（flag），但是我们考虑更简单的。套用直径删点的 trick，我们先求出全局最长路径，然后把这条路径拉直，在旁边挂子树。如果查询的点不在路径上，那么答案就是这条路径。如果在路径上，可以考虑对路径做前缀和后缀的答案，拼在一起就行；也可以采用缺一分治，往一侧走的时候加上另一侧的全部点，回退再撤销掉。

具体实现时要插入一个点并维护每个颜色的最远点对，这是 trival 的，新加的点只可能与原先的两个点构成贡献。

反正还挺好写的。

## 1009 记录 by SA

引入：[P3041](https://www.luogu.com.cn/problem/P3041)

AC 自动机上 dp。

[P4590](https://www.luogu.com.cn/problem/P4590)

我们 dp of dp 的板子。

考虑没有 LCS 的问题，我们容易有一个 dp $f_{i,j}$ 表示处理了兑奖串前 $i$ 位，目前 `NOI` 子串匹配到第 $j$ 位的方案数。

然后考虑我们如何记录 LCS 的长度。不妨回顾已知兑奖串时我们需要用一个 dp 来计算 LCS 的长度，那么我们在这里也必然需要用一个 dp 来计算。那么只能直接把 $f_i$ 处的 LCS 的 dp 数组塞进状态，然后每次 $i-1\to i$ 转移的同时也转移 LCS 的 dp，这是简单的。

注意 LCS 的 dp 数组不能直接塞。但我们可以塞 LCS 数组的差分，这样就只有 $0/1$ 了。另一个理解是我们塞奖章串当中 LCS 相匹配的位置。

[P5371](https://www.luogu.com.cn/problem/P5371)

注意初始牌是从牌堆内拿出的。

发现有太多顺子是无效的，因为可以直接转化为多个叠。设 $f_{i, j, k}$ 表示考虑前 $i$ 种牌，$(i - 1, i, i + 1)$ 有 $j$ 个，$(i, i + 1, i + 2)$ 有 $k$ 个的方案数（贪心先匹配较小者防止重复）。可以矩阵加速空挡部分的 dp。

[LOJ511](https://loj.ac/p/511)

独立集字典序比较可以转化为其对应的 $01$ 串的字典序比较（反过来）。

逐位确定，考虑树形 dp。设 $f_{u, 0/1}$ 表示考虑子树，$u$ 选/不选的独立集方案数。需支持单点修改，套上动态 dp。轻重链剖分/全局平衡二叉树，时间复杂度 $\mathcal O(n\log^2 n)\sim\mathcal O(n\log n)$。


_有 $n$ 个数，第 $i$ 个数的取值范围为 $[0, a_i]$。$q$ 次询问，所有数异或和为 $x$ 的方案数，对 $998244353$ 取模。_

设 $f_{i, j}$ 表示前 $i$ 个数异或和为 $j$ 的方案数，打表发现 $f$ 只有 $\log$ 种取值。

结论：设 $a_i$ 的异或和为 $g$，枚举答案与 $g$ 的 LCP，对于 LCP 相同的，方案数相同。

1. _有一个网格，每个网格可能是空格，也有可能是一个水管连接两边。最初有一些确定好的格子，求填充方案数，使得所有水管形成环。_

轮廓线 dp。

2. 在 1 的基础上，要求水管形成 $k$ 个回路。

$\mathcal O(\dfrac{3^n}{n^{1.5}})$

### 深夜研讨/se

1. ?

qoj8332 恶趣味题。注意到答案上界一定能取到，且存在 $l=1$ 的解。枚举 $r$ 即可。

[P4528](https://www.luogu.com.cn/problem/P4528) 图腾。

1324-1243-1432

=(1x2x-1423)-(14xx-1423)-(12xx-1234)

=1x2x-14xx-12xx+1234

=1x2x-1xxx+13xx+1234

发现 1x2x 与 13xx 在逆排列上等价，只需要算一个。都可以暴力容斥做。

1x2x 也可以考虑，“离线”枚举 $2$ 的位置。从小到大枚举 $2$ 的位置，将大于它的变为 $1$，小于它的变为 $0$，就很好做了。

2. P 行

树状数组：<https://www.luogu.com.cn/article/fxvx5qz6>


### 2024.10.11 模拟赛

#### T1

令 $s_i = \frac{1}{n}\sum_{j = 1}^{n}[a_j \leq i]$，问题等价与求出一个序列 $b_1,b_2,\dots,b_n$ 使得 $\sum_{i = 1}^{n}b_i = m$，最小化 $n - \sum_{i = 1}^{n}s_{b_i}$。

暴力 DP，定义 $dp_{i,j}$ 表示选了 $i$ 个非负整数，和为 $j$ 的最大的 $\sum s$。复杂度 $\Theta(nm^2)$。~~无数人亲测可过，不知为何。~~

#### T2

构造一个排列 $p$ 使得 $|p_i - i|$ 互不相同。

由于 $\frac{n \times (n - 1)}{2} \equiv \sum_{i = 1}^{n - 1}i \equiv \sum_{i = 1}^{n}|p_i - i| \equiv \sum_{i = 1}^{n}(p_i - i) \equiv 0 \pmod 2$。所以 $n \times (n - 1) \equiv 0 \pmod 4$，因此有解当且仅当 $n \equiv 0,1 \pmod 4$。

1. 当 $n = 4k$ 时，构造如下：

$$
p_i = \left\{\begin{matrix}
n - i + 1 & 1 \leq i \leq k\\
n - i & k + 1 \leq i \leq 2k - 1\\
1 & i = 2k\\
n - i + 1 & 2k + 1 \leq i \leq 3k - 1\\
n - k & i = 3k\\
n - i + 2 & 3k + 1 \leq i \leq 4k
\end{matrix}\right.
$$

2. 当 $n = 4k + 1$ 时，构造如下：

$$
p_i = \left\{\begin{matrix}
n - i + 1 & 1 \leq i \leq k\\
k + 2 & i = k + 2\\
n - i + 2 & k + 2 \leq i \leq 2k\\
1 & i = 2k + 1\\
n - i + 3 & 2k + 2 \leq i \leq 3k + 1\\
n - i + 2 & 3k + 2 \leq i \leq 4k + 1
\end{matrix}\right.
$$

-----------------

题解就是答辩。

显然题目可以转化成找一个排列 $p$ 使得 $|i-p_i|$ 不重不漏地取到 $0$ 到 $n-1$，我们考虑把

#### T3

[[ARC111F] Do you like query problems?](https://www.luogu.com.cn/problem/AT_arc111_f)

疑似是史上最水的 ARC F，但是 *3100。

显然考虑拆位，我们计算每一位被算进多少次和，然后

#### T4

CF506E

### 2024.10.11 课堂分享

#### T1 [AGC025E](https://www.luogu.com.cn/problem/AT_agc025_e)

> Hint 1：考虑答案上界：令第 $i$ 条边被经过次数为 $c_i$，则答案上界为 $\sum{\min(c_i,2)}$。\
> Hint 2：考虑当所有 $2 \mid c_i$ 的做法。注意到此时每一条链的端点也被覆盖了偶数次，那么我们将每一条链的两个端点连一条边，直接跑一次欧拉回路给无向边定向。

继续延续 Hint 2 的思路，将一条链的两个端点连边。但是会有边被覆盖奇数次，显然的，如果我们满足了两种方向的路径覆盖次数的差不超过 $1$ 一定是满足最优策略的。

考虑将度数不是偶数的点


#### T2 [CF1329D](https://www.luogu.com.cn/problem/CF1329D)

> Hint 1：考虑答案下界：；令 $c_i = \sum_{j = 1}^{n - 1}[a_j = i \wedge a_{j + 1} = i]$，则答案下界为 $\max(1,\max{c_i + 1},\frac{\sum{c_i}}{2})$。

#### T3 [CF1586I](https://www.luogu.com.cn/problem/CF1586I)


#### T4 [CF1994D](https://www.luogu.com.cn/problem/CF1994D)

#### T5 [ARC182C](https://www.luogu.com.cn/problem/AT_arc182_c)

#### T6 [AT_dwacon6th_prelims_c](https://www.luogu.com.cn/problem/AT_dwacon6th_prelims_c)

#### T7 [P10694](https://www.luogu.com.cn/problem/P10694)

#### T8 [AGC013E](https://www.luogu.com.cn/problem/AT_agc013_e)